
# 2025-12-01 10:21:46.223359
+Code the following app
+```
+Title: Path Finder Puzzle
+Description: A simple text-based maze. Choose directions to escape the labyrinth in as few moves as possible.
+
+Category: Game
+Style: Text-based logic puzzle.
+
+Persistent State:
+- maze (array of arrays)  // 0 = wall, 1 = path
+- playerX (number)
+- playerY (number)
+- exitX (number)
+- exitY (number)
+- moves (number)
+- message (string)
+- gameOver (boolean)
+
+On App Load:
+Call startGame().
+
+startGame():
+- Define a fixed 5x5 maze like:
+  maze = [
+    [1,1,0,1,1],
+    [0,1,0,1,0],
+    [1,1,1,1,1],
+    [1,0,0,0,1],
+    [1,1,1,0,1]
+  ]
+- playerX = 0
+- playerY = 0
+- exitX = 4
+- exitY = 4
+- moves = 0
+- gameOver = false
+- message = "Find your way to the exit!"
+- render()
+
+move(dir):
+If gameOver ‚Üí return.
+newX = playerX
+newY = playerY
+If dir == "Up" ‚Üí newY -= 1
+If dir == "Down" ‚Üí newY += 1
+If dir == "Left" ‚Üí newX -= 1
+If dir == "Right" ‚Üí newX += 1
+
+// Bounds check
+If newX < 0 OR newY < 0 OR newX > 4 OR newY > 4:
+    message = "You hit the boundary!"
+    render()
+    return
+
+// Wall check
+If maze[newY][newX] == 0:
+    message = "Blocked by a wall!"
+    render()
+    return
+
+// Valid move
+playerX = newX
+playerY = newY
+moves += 1
+message = "You moved " + dir + ". Moves: " + moves
+
+If playerX == exitX AND playerY == exitY:
+    endGame()
+
+render()
+
+endGame():
+gameOver = true
+message = "üèÅ Escaped! Total moves: " + moves
+render()
+
+UI REQUIREMENTS:
+Always display:
+- "Path Finder Puzzle"
+- "Player Position: (" + playerX + "," + playerY + ")"
+- "Exit: (" + exitX + "," + exitY + ")"
+- "Moves: " + moves
+- Message text
+
+If NOT gameOver:
+Buttons:
+- "Up" ‚Üí move("Up")
+- "Down" ‚Üí move("Down")
+- "Left" ‚Üí move("Left")
+- "Right" ‚Üí move("Right")
+
+If gameOver:
+Button:
+- "Restart" ‚Üí startGame()
+
+```
+
+Generate an app logo and update the app metadata title and description.

# 2025-12-01 10:21:46.223779
+Code the following app
+```
+Title: Path Finder Puzzle
+Description: A simple text-based maze. Choose directions to escape the labyrinth in as few moves as possible.
+
+Category: Game
+Style: Text-based logic puzzle.
+
+Persistent State:
+- maze (array of arrays)  // 0 = wall, 1 = path
+- playerX (number)
+- playerY (number)
+- exitX (number)
+- exitY (number)
+- moves (number)
+- message (string)
+- gameOver (boolean)
+
+On App Load:
+Call startGame().
+
+startGame():
+- Define a fixed 5x5 maze like:
+  maze = [
+    [1,1,0,1,1],
+    [0,1,0,1,0],
+    [1,1,1,1,1],
+    [1,0,0,0,1],
+    [1,1,1,0,1]
+  ]
+- playerX = 0
+- playerY = 0
+- exitX = 4
+- exitY = 4
+- moves = 0
+- gameOver = false
+- message = "Find your way to the exit!"
+- render()
+
+move(dir):
+If gameOver ‚Üí return.
+newX = playerX
+newY = playerY
+If dir == "Up" ‚Üí newY -= 1
+If dir == "Down" ‚Üí newY += 1
+If dir == "Left" ‚Üí newX -= 1
+If dir == "Right" ‚Üí newX += 1
+
+// Bounds check
+If newX < 0 OR newY < 0 OR newX > 4 OR newY > 4:
+    message = "You hit the boundary!"
+    render()
+    return
+
+// Wall check
+If maze[newY][newX] == 0:
+    message = "Blocked by a wall!"
+    render()
+    return
+
+// Valid move
+playerX = newX
+playerY = newY
+moves += 1
+message = "You moved " + dir + ". Moves: " + moves
+
+If playerX == exitX AND playerY == exitY:
+    endGame()
+
+render()
+
+endGame():
+gameOver = true
+message = "üèÅ Escaped! Total moves: " + moves
+render()
+
+UI REQUIREMENTS:
+Always display:
+- "Path Finder Puzzle"
+- "Player Position: (" + playerX + "," + playerY + ")"
+- "Exit: (" + exitX + "," + exitY + ")"
+- "Moves: " + moves
+- Message text
+
+If NOT gameOver:
+Buttons:
+- "Up" ‚Üí move("Up")
+- "Down" ‚Üí move("Down")
+- "Left" ‚Üí move("Left")
+- "Right" ‚Üí move("Right")
+
+If gameOver:
+Button:
+- "Restart" ‚Üí startGame()
+
+```
+
+Generate an app logo and update the app metadata title and description.

# 2025-12-01 10:35:35.537314
+Title: Path Finder Puzzle
+Description: A simple 5√ó5 maze where the player moves using buttons. The grid is fully visible using emoji icons.
+
+Category: Game
+Style: Text-based logic puzzle with emoji grid.
+
+Persistent State:
+- maze (array of arrays)    // 0=wall, 1=path
+- playerX (number)
+- playerY (number)
+- exitX (number)
+- exitY (number)
+- moves (number)
+- message (string)
+- gameOver (boolean)
+
+On App Load:
+Call startGame().
+
+startGame():
+maze = [
+  [1,1,0,1,1],
+  [0,1,0,1,0],
+  [1,1,1,1,1],
+  [1,0,0,0,1],
+  [1,1,1,0,1]
+]
+playerX = 0
+playerY = 0
+exitX = 4
+exitY = 4
+moves = 0
+message = "Find your way to the exit!"
+gameOver = false
+render()
+
+// Build visible maze as emoji grid
+buildGrid():
+Let output = ""
+For y in 0..4:
+  For x in 0..4:
+    If x==playerX AND y==playerY ‚Üí output += "üßç"
+    Else if x==exitX AND y==exitY ‚Üí output += "üü©"
+    Else if maze[y][x] == 0 ‚Üí output += "‚¨õ"   // wall
+    Else ‚Üí output += "‚¨ú"                      // path
+  output += "\n"
+return output
+
+move(dir):
+If gameOver ‚Üí return
+
+newX = playerX
+newY = playerY
+
+If dir=="Up" ‚Üí newY -= 1
+If dir=="Down" ‚Üí newY += 1
+If dir=="Left" ‚Üí newX -= 1
+If dir=="Right" ‚Üí newX += 1
+
+// Boundary check
+If newX < 0 OR newX > 4 OR newY < 0 OR newY > 4:
+  message = "You hit the boundary!"
+  render()
+  return
+
+// Wall check
+If maze[newY][newX] == 0:
+  message = "Blocked by a wall!"
+  render()
+  return
+
+// Move is valid
+playerX = newX
+playerY = newY
+moves += 1
+message = "You moved " + dir + ". Moves: " + moves
+
+If playerX==exitX AND playerY==exitY:
+  endGame()
+  return
+
+render()
+
+endGame():
+gameOver = true
+message = "üèÅ Escaped! Total moves: " + moves
+render()
+
+UI REQUIREMENTS:
+Always display:
+- "Path Finder Puzzle"
+- buildGrid()   // show the emoji maze grid
+- "Player Position: (" + playerX + "," + playerY + ")"
+- "Exit: (" + exitX + "," + exitY + ")"
+- "Moves: " + moves
+- Message text
+
+If NOT gameOver:
+Buttons:
+- "Up" ‚Üí move("Up")
+- "Down" ‚Üí move("Down")
+- "Left" ‚Üí move("Left")
+- "Right" ‚Üí move("Right")
+
+If gameOver:
+Button:
+- "Restart" ‚Üí startGame()
+

# 2025-12-01 10:35:35.537736
+Title: Path Finder Puzzle
+Description: A simple 5√ó5 maze where the player moves using buttons. The grid is fully visible using emoji icons.
+
+Category: Game
+Style: Text-based logic puzzle with emoji grid.
+
+Persistent State:
+- maze (array of arrays)    // 0=wall, 1=path
+- playerX (number)
+- playerY (number)
+- exitX (number)
+- exitY (number)
+- moves (number)
+- message (string)
+- gameOver (boolean)
+
+On App Load:
+Call startGame().
+
+startGame():
+maze = [
+  [1,1,0,1,1],
+  [0,1,0,1,0],
+  [1,1,1,1,1],
+  [1,0,0,0,1],
+  [1,1,1,0,1]
+]
+playerX = 0
+playerY = 0
+exitX = 4
+exitY = 4
+moves = 0
+message = "Find your way to the exit!"
+gameOver = false
+render()
+
+// Build visible maze as emoji grid
+buildGrid():
+Let output = ""
+For y in 0..4:
+  For x in 0..4:
+    If x==playerX AND y==playerY ‚Üí output += "üßç"
+    Else if x==exitX AND y==exitY ‚Üí output += "üü©"
+    Else if maze[y][x] == 0 ‚Üí output += "‚¨õ"   // wall
+    Else ‚Üí output += "‚¨ú"                      // path
+  output += "\n"
+return output
+
+move(dir):
+If gameOver ‚Üí return
+
+newX = playerX
+newY = playerY
+
+If dir=="Up" ‚Üí newY -= 1
+If dir=="Down" ‚Üí newY += 1
+If dir=="Left" ‚Üí newX -= 1
+If dir=="Right" ‚Üí newX += 1
+
+// Boundary check
+If newX < 0 OR newX > 4 OR newY < 0 OR newY > 4:
+  message = "You hit the boundary!"
+  render()
+  return
+
+// Wall check
+If maze[newY][newX] == 0:
+  message = "Blocked by a wall!"
+  render()
+  return
+
+// Move is valid
+playerX = newX
+playerY = newY
+moves += 1
+message = "You moved " + dir + ". Moves: " + moves
+
+If playerX==exitX AND playerY==exitY:
+  endGame()
+  return
+
+render()
+
+endGame():
+gameOver = true
+message = "üèÅ Escaped! Total moves: " + moves
+render()
+
+UI REQUIREMENTS:
+Always display:
+- "Path Finder Puzzle"
+- buildGrid()   // show the emoji maze grid
+- "Player Position: (" + playerX + "," + playerY + ")"
+- "Exit: (" + exitX + "," + exitY + ")"
+- "Moves: " + moves
+- Message text
+
+If NOT gameOver:
+Buttons:
+- "Up" ‚Üí move("Up")
+- "Down" ‚Üí move("Down")
+- "Left" ‚Üí move("Left")
+- "Right" ‚Üí move("Right")
+
+If gameOver:
+Button:
+- "Restart" ‚Üí startGame()
+

# 2025-12-01 10:52:05.486845
+Title: Monster Chase Maze
+Description: Escape the colorful maze before the monster catches you! You have limited time and the monster moves toward you every turn.
+
+Category: Game
+Style: Text-based with emoji grid, timer, and chasing monster.
+
+Persistent State:
+- maze (array of arrays)  // 0=wall, 1=path
+- playerX (number)
+- playerY (number)
+- monsterX (number)
+- monsterY (number)
+- exitX (number)
+- exitY (number)
+- moves (number)
+- timeLeft (number)
+- message (string)
+- gameOver (boolean)
+
+On App Load:
+Call startGame()
+
+startGame():
+maze = [
+  [1,1,0,1,1],
+  [0,1,0,1,0],
+  [1,1,1,1,1],
+  [1,0,0,0,1],
+  [1,1,1,0,1]
+]
+playerX = 0
+playerY = 0
+monsterX = 2
+monsterY = 2
+exitX = 4
+exitY = 4
+moves = 0
+timeLeft = 20   // 20 turns before time runs out
+message = "Escape the maze! The monster is chasing you!"
+gameOver = false
+render()
+
+// Build colorful emoji maze
+buildGrid():
+let out = ""
+For y in 0..4:
+  For x in 0..4:
+    If x==playerX AND y==playerY ‚Üí out += "üßç"
+    Else if x==monsterX AND y==monsterY ‚Üí out += "üëæ"
+    Else if x==exitX AND y==exitY ‚Üí out += "üü©"
+    Else if maze[y][x]==0 ‚Üí out += "üü•"   // wall
+    Else out += "üü¶"                      // path
+  out += "\n"
+return out
+
+// Player move
+move(dir):
+If gameOver ‚Üí return
+
+newX = playerX
+newY = playerY
+
+If dir=="Up"    ‚Üí newY -= 1
+If dir=="Down"  ‚Üí newY += 1
+If dir=="Left"  ‚Üí newX -= 1
+If dir=="Right" ‚Üí newX += 1
+
+// Boundary check
+If newX < 0 OR newX > 4 OR newY < 0 OR newY > 4:
+  message = "Boundary!"
+  render()
+  return
+
+// Wall check
+If maze[newY][newX] == 0:
+  message = "You hit a wall!"
+  render()
+  return
+
+// Valid move
+playerX = newX
+playerY = newY
+moves += 1
+timeLeft -= 1
+message = "You moved " + dir + ". Time left: " + timeLeft
+
+// Win condition
+If playerX==exitX AND playerY==exitY:
+  endGame(true)
+  return
+
+// Monster moves
+monsterMove()
+
+// Time check
+If timeLeft <= 0:
+  message = "‚è≥ Time is up!"
+  endGame(false)
+  return
+
+render()
+
+// Monster logic: move 1 step closer to player
+monsterMove():
+let dx = playerX - monsterX
+let dy = playerY - monsterY
+
+If Math.abs(dx) > Math.abs(dy):
+  monsterX += Math.sign(dx)
+Else:
+  monsterY += Math.sign(dy)
+
+If monsterX==playerX AND monsterY==playerY:
+  endGame(false)
+
+// End game
+endGame(won):
+gameOver = true
+If won:
+  message = "üèÜ You escaped! Moves: " + moves
+Else:
+  message = "üíÄ The monster caught you!"
+render()
+
+// UI
+UI REQUIREMENTS:
+Always show:
+- "Monster Chase Maze"
+- buildGrid()
+- "Player: ("+playerX+","+playerY+")"
+- "Monster: ("+monsterX+","+monsterY+")"
+- "Exit: ("+exitX+","+exitY+")"
+- "Moves: "+moves
+- "Time Left: "+timeLeft
+- message
+
+If NOT gameOver:
+Buttons:
+- Up ‚Üí move("Up")
+- Down ‚Üí move("Down")
+- Left ‚Üí move("Left")
+- Right ‚Üí move("Right")
+
+If gameOver:
+Button:
+- Restart ‚Üí startGame()
+

# 2025-12-01 10:52:05.487288
+Title: Monster Chase Maze
+Description: Escape the colorful maze before the monster catches you! You have limited time and the monster moves toward you every turn.
+
+Category: Game
+Style: Text-based with emoji grid, timer, and chasing monster.
+
+Persistent State:
+- maze (array of arrays)  // 0=wall, 1=path
+- playerX (number)
+- playerY (number)
+- monsterX (number)
+- monsterY (number)
+- exitX (number)
+- exitY (number)
+- moves (number)
+- timeLeft (number)
+- message (string)
+- gameOver (boolean)
+
+On App Load:
+Call startGame()
+
+startGame():
+maze = [
+  [1,1,0,1,1],
+  [0,1,0,1,0],
+  [1,1,1,1,1],
+  [1,0,0,0,1],
+  [1,1,1,0,1]
+]
+playerX = 0
+playerY = 0
+monsterX = 2
+monsterY = 2
+exitX = 4
+exitY = 4
+moves = 0
+timeLeft = 20   // 20 turns before time runs out
+message = "Escape the maze! The monster is chasing you!"
+gameOver = false
+render()
+
+// Build colorful emoji maze
+buildGrid():
+let out = ""
+For y in 0..4:
+  For x in 0..4:
+    If x==playerX AND y==playerY ‚Üí out += "üßç"
+    Else if x==monsterX AND y==monsterY ‚Üí out += "üëæ"
+    Else if x==exitX AND y==exitY ‚Üí out += "üü©"
+    Else if maze[y][x]==0 ‚Üí out += "üü•"   // wall
+    Else out += "üü¶"                      // path
+  out += "\n"
+return out
+
+// Player move
+move(dir):
+If gameOver ‚Üí return
+
+newX = playerX
+newY = playerY
+
+If dir=="Up"    ‚Üí newY -= 1
+If dir=="Down"  ‚Üí newY += 1
+If dir=="Left"  ‚Üí newX -= 1
+If dir=="Right" ‚Üí newX += 1
+
+// Boundary check
+If newX < 0 OR newX > 4 OR newY < 0 OR newY > 4:
+  message = "Boundary!"
+  render()
+  return
+
+// Wall check
+If maze[newY][newX] == 0:
+  message = "You hit a wall!"
+  render()
+  return
+
+// Valid move
+playerX = newX
+playerY = newY
+moves += 1
+timeLeft -= 1
+message = "You moved " + dir + ". Time left: " + timeLeft
+
+// Win condition
+If playerX==exitX AND playerY==exitY:
+  endGame(true)
+  return
+
+// Monster moves
+monsterMove()
+
+// Time check
+If timeLeft <= 0:
+  message = "‚è≥ Time is up!"
+  endGame(false)
+  return
+
+render()
+
+// Monster logic: move 1 step closer to player
+monsterMove():
+let dx = playerX - monsterX
+let dy = playerY - monsterY
+
+If Math.abs(dx) > Math.abs(dy):
+  monsterX += Math.sign(dx)
+Else:
+  monsterY += Math.sign(dy)
+
+If monsterX==playerX AND monsterY==playerY:
+  endGame(false)
+
+// End game
+endGame(won):
+gameOver = true
+If won:
+  message = "üèÜ You escaped! Moves: " + moves
+Else:
+  message = "üíÄ The monster caught you!"
+render()
+
+// UI
+UI REQUIREMENTS:
+Always show:
+- "Monster Chase Maze"
+- buildGrid()
+- "Player: ("+playerX+","+playerY+")"
+- "Monster: ("+monsterX+","+monsterY+")"
+- "Exit: ("+exitX+","+exitY+")"
+- "Moves: "+moves
+- "Time Left: "+timeLeft
+- message
+
+If NOT gameOver:
+Buttons:
+- Up ‚Üí move("Up")
+- Down ‚Üí move("Down")
+- Left ‚Üí move("Left")
+- Right ‚Üí move("Right")
+
+If gameOver:
+Button:
+- Restart ‚Üí startGame()
+

# 2025-12-02 17:43:37.080317
+Title: Monster Maze Escape ‚Äì Large & Moving Monster
+Description: Escape the maze! Player üßç, Monster üëæ, Exit üü©. Quadrati grandi 50x50px. Monster sempre si muove verso giocatore.
+
+Persistent State:
+- maze (array of arrays) 0=wall,1=path
+- playerX, playerY
+- monsterX, monsterY
+- exitX, exitY
+- moves, timeLeft, message, gameOver
+- rows=7, cols=7
+
+startGame():
+maze = generateMaze(rows, cols)
+playerX=0; playerY=0
+monsterX=cols-1; monsterY=rows-1
+do:
+  exitX=randomInt(1,cols-2)
+  exitY=randomInt(1,rows-2)
+while maze[exitY][exitX]==0 || (exitX==playerX && exitY==playerY) || (exitX==monsterX && exitY==monsterY)
+moves=0; timeLeft=30; gameOver=false
+message="Escape the maze! Monster is chasing you!"
+render()
+
+buildGrid():
+for y=0..rows-1:
+  for x=0..cols-1:
+    cell = createDiv()
+    cell.width=50px; cell.height=50px; cell.border="1px solid black"
+    if x==playerX && y==playerY then cell.backgroundColor="blue"
+    else if x==monsterX && y==monsterY then cell.backgroundColor="red"
+    else if x==exitX && y==exitY then cell.backgroundColor="green"
+    else if maze[y][x]==0 then cell.backgroundColor="black"
+    else cell.backgroundColor="white"
+    appendToGridContainer(cell)
+
+move(dir):
+// check bordi e muri
+// aggiorna playerX/Y
+moves+=1; timeLeft-=1
+checkWin()
+monsterMove()
+checkMonsterCaught()
+render()
+
+monsterMove():
+dx=playerX-monsterX
+dy=playerY-monsterY
+moved=false
+// prova orizzontale
+if dx!=0:
+  nx=monsterX+sign(dx)
+  if maze[monsterY][nx]==1 then monsterX=nx; moved=true
+// prova verticale se non si √® mosso
+if !moved && dy!=0:
+  ny=monsterY+sign(dy)
+  if maze[ny][monsterX]==1 then monsterY=ny; moved=true
+// se ancora bloccato, resta fermo
+
+checkWin():
+if playerX==exitX && playerY==exitY then endGame(true)
+if monsterX==playerX && monsterY==playerY then endGame(false)
+if timeLeft<=0 then endGame(false)
+
+endGame(won):
+gameOver=true
+message=won?"üèÜ Escaped!":"üíÄ Caught by monster!"
+
+Restart button:
+sempre visibile, chiama startGame()
+

# 2025-12-02 17:43:37.081263
+Title: Monster Maze Escape ‚Äì Large & Moving Monster
+Description: Escape the maze! Player üßç, Monster üëæ, Exit üü©. Quadrati grandi 50x50px. Monster sempre si muove verso giocatore.
+
+Persistent State:
+- maze (array of arrays) 0=wall,1=path
+- playerX, playerY
+- monsterX, monsterY
+- exitX, exitY
+- moves, timeLeft, message, gameOver
+- rows=7, cols=7
+
+startGame():
+maze = generateMaze(rows, cols)
+playerX=0; playerY=0
+monsterX=cols-1; monsterY=rows-1
+do:
+  exitX=randomInt(1,cols-2)
+  exitY=randomInt(1,rows-2)
+while maze[exitY][exitX]==0 || (exitX==playerX && exitY==playerY) || (exitX==monsterX && exitY==monsterY)
+moves=0; timeLeft=30; gameOver=false
+message="Escape the maze! Monster is chasing you!"
+render()
+
+buildGrid():
+for y=0..rows-1:
+  for x=0..cols-1:
+    cell = createDiv()
+    cell.width=50px; cell.height=50px; cell.border="1px solid black"
+    if x==playerX && y==playerY then cell.backgroundColor="blue"
+    else if x==monsterX && y==monsterY then cell.backgroundColor="red"
+    else if x==exitX && y==exitY then cell.backgroundColor="green"
+    else if maze[y][x]==0 then cell.backgroundColor="black"
+    else cell.backgroundColor="white"
+    appendToGridContainer(cell)
+
+move(dir):
+// check bordi e muri
+// aggiorna playerX/Y
+moves+=1; timeLeft-=1
+checkWin()
+monsterMove()
+checkMonsterCaught()
+render()
+
+monsterMove():
+dx=playerX-monsterX
+dy=playerY-monsterY
+moved=false
+// prova orizzontale
+if dx!=0:
+  nx=monsterX+sign(dx)
+  if maze[monsterY][nx]==1 then monsterX=nx; moved=true
+// prova verticale se non si √® mosso
+if !moved && dy!=0:
+  ny=monsterY+sign(dy)
+  if maze[ny][monsterX]==1 then monsterY=ny; moved=true
+// se ancora bloccato, resta fermo
+
+checkWin():
+if playerX==exitX && playerY==exitY then endGame(true)
+if monsterX==playerX && monsterY==playerY then endGame(false)
+if timeLeft<=0 then endGame(false)
+
+endGame(won):
+gameOver=true
+message=won?"üèÜ Escaped!":"üíÄ Caught by monster!"
+
+Restart button:
+sempre visibile, chiama startGame()
+

# 2025-12-02 18:08:46.424279
+Player Position: (0,0)
+
+Monster Position: (6,6)
+
+Exit: (5,5)
+
+Moves: 0

# 2025-12-02 18:08:46.424639
+Player Position: (0,0)
+
+Monster Position: (6,6)
+
+Exit: (5,5)
+
+Moves: 0

# 2025-12-02 18:21:35.840784
+Title: Monster Chase Maze 10√ó10 Neon Smooth
+Description: A neon-colored maze game with smooth animations, random 10√ó10 labyrinth generation, and a monster that intelligently chases the player.
+Category: Game
+
+Persistent State:
+- maze (10√ó10 grid)
+- rows = 10
+- cols = 
+

# 2025-12-02 18:21:35.846393
+Title: Monster Chase Maze 10√ó10 Neon Smooth
+Description: A neon-colored maze game with smooth animations, random 10√ó10 labyrinth generation, and a monster that intelligently chases the player.
+Category: Game
+
+Persistent State:
+- maze (10√ó10 grid)
+- rows = 10
+- cols = 
+

# 2025-12-02 18:41:29.122758
+Title: Monster Chase Maze 10x10 Neon
+Description: Escape the maze while a monster chases you. Every run generates a new valid maze with a guaranteed path to the exit.
+Category: Game
+
+Persistent State:
+- maze (array)
+- rows (number)
+- cols (number)
+- playerX (number)
+- playerY (number)
+- monsterX (number)
+- monsterY (number)
+- exitX (number)
+- exitY (number)
+- moves (number)
+- timeLeft (number)
+- message (string)
+- gameOver (boolean)
+
+On App Load:
+Call initGame().
+
+initGame():
+rows = 10
+cols = 10
+gameOver = false
+moves = 0
+timeLeft = 30
+message = "Escape the maze!"
+
+// Generate maze using guaranteed-carve algorithm
+maze = []
+for y from 0..rows-1:
+    row = []
+    for x from 0..cols-1:
+        row.push(1)   // start as wall
+    maze.push(row)
+
+// Carve path from (0,0) to (9,9)
+px = 0
+py = 0
+maze[py][px] = 0
+while px != cols-1 or py != rows-1:
+    if random() < 0.5:
+        if px < cols-1:
+            px += 1
+    else:
+        if py < rows-1:
+            py += 1
+    maze[py][px] = 0
+
+// Add random extra openings
+for i in 0..30:
+    rx = floor(random()*cols)
+    ry = floor(random()*rows)
+    maze[ry][rx] = 0
+
+// Set positions
+playerX = 0
+playerY = 0
+monsterX = cols-1
+monsterY = rows-1
+exitX = cols-1
+exitY = rows-1
+
+render()
+
+move(dir):
+If gameOver ‚Üí return
+
+nx = playerX
+ny = playerY
+
+If dir == "Up" ‚Üí ny -= 1
+If dir == "Down" ‚Üí ny += 1
+If dir == "Left" ‚Üí nx -= 1
+If dir == "Right" ‚Üí nx += 1
+
+// bounds
+If nx < 0 or ny < 0 or nx >= cols or ny >= rows:
+    return
+
+// wall check
+If maze[ny][nx] == 1:
+    return
+
+// Move player
+playerX = nx
+playerY = ny
+moves += 1
+timeLeft -= 1
+
+// Win
+If playerX == exitX AND playerY == exitY:
+    endGame(true)
+    return
+
+// Monster movement (simple chase)
+dx = playerX - monsterX
+dy = playerY - monsterY
+
+If abs(dx) > abs(dy):
+    monsterX += sign(dx)
+else:
+    monsterY += sign(dy)
+
+// Monster avoids walls
+If maze[monsterY][monsterX] == 1:
+    monsterX = monsterX
+    monsterY = monsterY
+
+// Lose
+If monsterX == playerX AND monsterY == playerY:
+    endGame(false)
+    return
+
+If timeLeft <= 0:
+    endGame(false)
+    return
+
+render()
+
+endGame(win):
+gameOver = true
+If win ‚Üí message = "üèÜ You escaped!"
+Else ‚Üí message = "üíÄ The monster caught you!"
+render()
+
+UI RENDERING:
+Show only:
+- "Monster Chase Maze"
+- message
+- big grid (10x10)
+
+Grid rendering rules:
+- wall ‚Üí "üü•"
+- path ‚Üí "üü¶"
+- player ‚Üí "üü©"
+- monster ‚Üí "üü™"
+- exit ‚Üí "üüß"
+
+Buttons (if NOT gameOver):
+Up ‚Üí move("Up")
+Down ‚Üí move("Down")
+Left ‚Üí move("Left")
+Right ‚Üí move("Right")
+
+If gameOver:
+Button ‚Üí "Restart" ‚Üí initGame()
+

# 2025-12-02 18:41:29.123443
+Title: Monster Chase Maze 10x10 Neon
+Description: Escape the maze while a monster chases you. Every run generates a new valid maze with a guaranteed path to the exit.
+Category: Game
+
+Persistent State:
+- maze (array)
+- rows (number)
+- cols (number)
+- playerX (number)
+- playerY (number)
+- monsterX (number)
+- monsterY (number)
+- exitX (number)
+- exitY (number)
+- moves (number)
+- timeLeft (number)
+- message (string)
+- gameOver (boolean)
+
+On App Load:
+Call initGame().
+
+initGame():
+rows = 10
+cols = 10
+gameOver = false
+moves = 0
+timeLeft = 30
+message = "Escape the maze!"
+
+// Generate maze using guaranteed-carve algorithm
+maze = []
+for y from 0..rows-1:
+    row = []
+    for x from 0..cols-1:
+        row.push(1)   // start as wall
+    maze.push(row)
+
+// Carve path from (0,0) to (9,9)
+px = 0
+py = 0
+maze[py][px] = 0
+while px != cols-1 or py != rows-1:
+    if random() < 0.5:
+        if px < cols-1:
+            px += 1
+    else:
+        if py < rows-1:
+            py += 1
+    maze[py][px] = 0
+
+// Add random extra openings
+for i in 0..30:
+    rx = floor(random()*cols)
+    ry = floor(random()*rows)
+    maze[ry][rx] = 0
+
+// Set positions
+playerX = 0
+playerY = 0
+monsterX = cols-1
+monsterY = rows-1
+exitX = cols-1
+exitY = rows-1
+
+render()
+
+move(dir):
+If gameOver ‚Üí return
+
+nx = playerX
+ny = playerY
+
+If dir == "Up" ‚Üí ny -= 1
+If dir == "Down" ‚Üí ny += 1
+If dir == "Left" ‚Üí nx -= 1
+If dir == "Right" ‚Üí nx += 1
+
+// bounds
+If nx < 0 or ny < 0 or nx >= cols or ny >= rows:
+    return
+
+// wall check
+If maze[ny][nx] == 1:
+    return
+
+// Move player
+playerX = nx
+playerY = ny
+moves += 1
+timeLeft -= 1
+
+// Win
+If playerX == exitX AND playerY == exitY:
+    endGame(true)
+    return
+
+// Monster movement (simple chase)
+dx = playerX - monsterX
+dy = playerY - monsterY
+
+If abs(dx) > abs(dy):
+    monsterX += sign(dx)
+else:
+    monsterY += sign(dy)
+
+// Monster avoids walls
+If maze[monsterY][monsterX] == 1:
+    monsterX = monsterX
+    monsterY = monsterY
+
+// Lose
+If monsterX == playerX AND monsterY == playerY:
+    endGame(false)
+    return
+
+If timeLeft <= 0:
+    endGame(false)
+    return
+
+render()
+
+endGame(win):
+gameOver = true
+If win ‚Üí message = "üèÜ You escaped!"
+Else ‚Üí message = "üíÄ The monster caught you!"
+render()
+
+UI RENDERING:
+Show only:
+- "Monster Chase Maze"
+- message
+- big grid (10x10)
+
+Grid rendering rules:
+- wall ‚Üí "üü•"
+- path ‚Üí "üü¶"
+- player ‚Üí "üü©"
+- monster ‚Üí "üü™"
+- exit ‚Üí "üüß"
+
+Buttons (if NOT gameOver):
+Up ‚Üí move("Up")
+Down ‚Üí move("Down")
+Left ‚Üí move("Left")
+Right ‚Üí move("Right")
+
+If gameOver:
+Button ‚Üí "Restart" ‚Üí initGame()
+

# 2025-12-02 19:14:42.922652
+Title: Monster Chase Neon Maze
+Description: Navigate a neon maze while a monster hunts you. Smooth movement simulation, intelligent monster, and guaranteed solvable maze.
+Category: Game
+
+Persistent State:
+- maze
+- rows
+- cols
+- playerX
+- playerY
+- monsterX
+- monsterY
+- exitX
+- exitY
+- message
+- gameOver
+- animStep
+- animMax
+
+On App Load:
+Call initGame().
+
+initGame():
+rows = 10
+cols = 10
+gameOver = false
+animStep = 0
+animMax = 2
+message = "Escape the maze!"
+
+// Generate empty maze
+maze = []
+for y 0..rows-1:
+  row = []
+  for x 0..cols-1:
+    row.push(1)
+  maze.push(row)
+
+// Guaranteed path carving
+px = 0
+py = 0
+maze[py][px] = 0
+while px != cols-1 or py != rows-1:
+  if random() < 0.5 and px < cols-1:
+    px += 1
+  else if py < rows-1:
+    py += 1
+  maze[py][px] = 0
+
+// Add random openings
+for i 0..40:
+  rx = floor(random()*cols)
+  ry = floor(random()*rows)
+  maze[ry][rx] = 0
+
+// Starting positions
+playerX = 0
+playerY = 0
+exitX = cols-1
+exitY = rows-1
+monsterX = cols-1
+monsterY = rows-2
+
+render()
+
+
+// MOVEMENT ------------------------------------------------
+
+move(dir):
+if gameOver ‚Üí return
+
+nx = playerX
+ny = playerY
+
+if dir == "Up": ny -= 1
+if dir == "Down": ny += 1
+if dir == "Left": nx -= 1
+if dir == "Right": nx += 1
+
+if nx < 0 or ny < 0 or nx >= cols or ny >= rows:
+  return
+
+if maze[ny][nx] == 1:
+  return
+
+// smooth animation
+animStep = 0
+animatePlayer(nx, ny)
+
+animatePlayer(nx, ny):
+if animStep < animMax:
+  animStep += 1
+  render()
+  return
+
+playerX = nx
+playerY = ny
+
+if playerX == exitX and playerY == exitY:
+  endGame(true)
+  return
+
+monsterChase()
+render()
+
+
+// MONSTER AI ---------------------------------------------
+
+monsterChase():
+dx = playerX - monsterX
+dy = playerY - monsterY
+
+options = []
+
+if abs(dx) > abs(dy):
+  options.push([monsterX + sign(dx), monsterY])
+  options.push([monsterX, monsterY + sign(dy)])
+else:
+  options.push([monsterX, monsterY + sign(dy)])
+  options.push([monsterX + sign(dx), monsterY])
+
+// fallback
+options.push([monsterX+1, monsterY])
+options.push([monsterX-1, monsterY])
+options.push([monsterX, monsterY+1])
+options.push([monsterX, monsterY-1])
+
+for each op in options:
+  ox = op[0]
+  oy = op[1]
+  if ox >= 0 and oy >= 0 and ox < cols and oy < rows:
+    if maze[oy][ox] == 0:
+       monsterX = ox
+       monsterY = oy
+       break
+
+if monsterX == playerX and monsterY == playerY:
+  endGame(false)
+
+
+// ENDGAME ----------------------------------------------
+
+endGame(win):
+gameOver = true
+if win:
+  message = "üèÜ You escaped!"
+else:
+  message = "üíÄ The monster caught you!"
+render()
+
+
+
+// RENDER ------------------------------------------------
+
+render():
+grid = ""
+for y 0..rows-1:
+  row = ""
+  for x 0..cols-1:
+    if x == playerX and y == playerY:
+      row += "üßç"
+    else if x == monsterX and y == monsterY:
+      row += "üëπ"
+    else if x == exitX and y == exitY:
+      row += "üüß"
+    else if maze[y][x] == 1:
+      row += "üü•"
+    else:
+      row += "üü¶"
+  grid += row + "\n"
+
+Display:
+- "Monster Chase Maze"
+- message
+- grid
+
+If NOT gameOver:
+  Buttons:
+    Up ‚Üí move("Up")
+    Down ‚Üí move("Down")
+    Left ‚Üí move("Left")
+    Right ‚Üí move("Right")
+
+Else:
+  Button: "Restart" ‚Üí initGame()
+

# 2025-12-02 19:14:42.924527
+Title: Monster Chase Neon Maze
+Description: Navigate a neon maze while a monster hunts you. Smooth movement simulation, intelligent monster, and guaranteed solvable maze.
+Category: Game
+
+Persistent State:
+- maze
+- rows
+- cols
+- playerX
+- playerY
+- monsterX
+- monsterY
+- exitX
+- exitY
+- message
+- gameOver
+- animStep
+- animMax
+
+On App Load:
+Call initGame().
+
+initGame():
+rows = 10
+cols = 10
+gameOver = false
+animStep = 0
+animMax = 2
+message = "Escape the maze!"
+
+// Generate empty maze
+maze = []
+for y 0..rows-1:
+  row = []
+  for x 0..cols-1:
+    row.push(1)
+  maze.push(row)
+
+// Guaranteed path carving
+px = 0
+py = 0
+maze[py][px] = 0
+while px != cols-1 or py != rows-1:
+  if random() < 0.5 and px < cols-1:
+    px += 1
+  else if py < rows-1:
+    py += 1
+  maze[py][px] = 0
+
+// Add random openings
+for i 0..40:
+  rx = floor(random()*cols)
+  ry = floor(random()*rows)
+  maze[ry][rx] = 0
+
+// Starting positions
+playerX = 0
+playerY = 0
+exitX = cols-1
+exitY = rows-1
+monsterX = cols-1
+monsterY = rows-2
+
+render()
+
+
+// MOVEMENT ------------------------------------------------
+
+move(dir):
+if gameOver ‚Üí return
+
+nx = playerX
+ny = playerY
+
+if dir == "Up": ny -= 1
+if dir == "Down": ny += 1
+if dir == "Left": nx -= 1
+if dir == "Right": nx += 1
+
+if nx < 0 or ny < 0 or nx >= cols or ny >= rows:
+  return
+
+if maze[ny][nx] == 1:
+  return
+
+// smooth animation
+animStep = 0
+animatePlayer(nx, ny)
+
+animatePlayer(nx, ny):
+if animStep < animMax:
+  animStep += 1
+  render()
+  return
+
+playerX = nx
+playerY = ny
+
+if playerX == exitX and playerY == exitY:
+  endGame(true)
+  return
+
+monsterChase()
+render()
+
+
+// MONSTER AI ---------------------------------------------
+
+monsterChase():
+dx = playerX - monsterX
+dy = playerY - monsterY
+
+options = []
+
+if abs(dx) > abs(dy):
+  options.push([monsterX + sign(dx), monsterY])
+  options.push([monsterX, monsterY + sign(dy)])
+else:
+  options.push([monsterX, monsterY + sign(dy)])
+  options.push([monsterX + sign(dx), monsterY])
+
+// fallback
+options.push([monsterX+1, monsterY])
+options.push([monsterX-1, monsterY])
+options.push([monsterX, monsterY+1])
+options.push([monsterX, monsterY-1])
+
+for each op in options:
+  ox = op[0]
+  oy = op[1]
+  if ox >= 0 and oy >= 0 and ox < cols and oy < rows:
+    if maze[oy][ox] == 0:
+       monsterX = ox
+       monsterY = oy
+       break
+
+if monsterX == playerX and monsterY == playerY:
+  endGame(false)
+
+
+// ENDGAME ----------------------------------------------
+
+endGame(win):
+gameOver = true
+if win:
+  message = "üèÜ You escaped!"
+else:
+  message = "üíÄ The monster caught you!"
+render()
+
+
+
+// RENDER ------------------------------------------------
+
+render():
+grid = ""
+for y 0..rows-1:
+  row = ""
+  for x 0..cols-1:
+    if x == playerX and y == playerY:
+      row += "üßç"
+    else if x == monsterX and y == monsterY:
+      row += "üëπ"
+    else if x == exitX and y == exitY:
+      row += "üüß"
+    else if maze[y][x] == 1:
+      row += "üü•"
+    else:
+      row += "üü¶"
+  grid += row + "\n"
+
+Display:
+- "Monster Chase Maze"
+- message
+- grid
+
+If NOT gameOver:
+  Buttons:
+    Up ‚Üí move("Up")
+    Down ‚Üí move("Down")
+    Left ‚Üí move("Left")
+    Right ‚Üí move("Right")
+
+Else:
+  Button: "Restart" ‚Üí initGame()
+

# 2025-12-02 19:42:44.843772
+Title: Monster Chase Maze ‚Äî Emoji Grid (Fixed)
+Description: 10√ó10 neon maze. Player üßç and Monster üëπ shown as emoji, exit üüß. Big visible grid, restart always works. Monster chase logic fixed.
+
+Category: Game
+Style: Text + emoji grid, DOM-friendly.
+
+Persistent State:
+- maze (2D array)          // 0 = wall, 1 = path
+- rows = 10
+- cols = 10
+- playerX, playerY
+- monsterX, monsterY
+- exitX, exitY
+- moves, timeLeft
+- message
+- gameOver
+
+On App Load:
+Call initGame() automatically.
+
+initGame():
+- rows = 10; cols = 10
+- // create full walls
+- maze = new 2D array rows√ócols with all cells = 0
+- // carve a guaranteed path from (0,0) to (cols-1,rows-1)
+- x = 0; y = 0; maze[y][x] = 1
+- while x < cols-1 or y < rows-1:
+    if Math.random() < 0.5 and x < cols-1:
+      x += 1
+    else if y < rows-1:
+      y += 1
+    maze[y][x] = 1
+- // open extra random path cells so maze is not a straight corridor
+- for i from 0 to 40:
+    rx = floor(Math.random()*cols); ry = floor(Math.random()*rows)
+    maze[ry][rx] = 1
+- // choose start / monster / exit on path cells
+- playerX = 0; playerY = 0; // ensure maze[0][0] == 1
+- // find monster start: search for a path cell near bottom-right
+- monsterX = cols-1; monsterY = rows-1
+- if maze[monsterY][monsterX] == 0:
+    // find nearest path cell to bottom-right
+    for yy from rows-1 downto 0:
+      for xx from cols-1 downto 0:
+        if maze[yy][xx] == 1:
+           monsterX = xx; monsterY = yy; break loops
+- // set exit to a random path cell not overlapping player/monster
+- do:
+    exitX = floor(Math.random()*cols); exitY = floor(Math.random()*rows)
+  while maze[exitY][exitX] != 1 || (exitX==playerX && exitY==playerY) || (exitX==monsterX && exitY==monsterY)
+- moves = 0; timeLeft = 30; gameOver = false
+- message = "Escape the maze! Use buttons. Restart always available."
+- render()
+
+// Movement input
+move(dir):
+- if gameOver return
+- nx = playerX; ny = playerY
+- if dir=="Up" then ny -= 1
+- if dir=="Down" then ny += 1
+- if dir=="Left" then nx -= 1
+- if dir=="Right" then nx += 1
+- if nx < 0 || ny < 0 || nx >= cols || ny >= rows then return
+- if maze[ny][nx] == 0 then return
+- // valid: move player
+- playerX = nx; playerY = ny; moves += 1; timeLeft -= 1
+- // win check
+- if playerX==exitX && playerY==exitY: endGame(true); return
+- // monster moves after player
+- monsterMove()
+- // monster catches player?
+- if monsterX==playerX && monsterY==playerY: endGame(false); return
+- if timeLeft <= 0: endGame(false); return
+- render()
+
+// Monster movement (fixed logic)
+monsterMove():
+- if gameOver return
+- dx = playerX - monsterX; dy = playerY - monsterY
+- options = []
+- // prioritize reducing larger distance first (try horizontal then vertical or vice versa)
+- if Math.abs(dx) >= Math.abs(dy):
+    options.push([monsterX + Math.sign(dx), monsterY])   // try horizontal
+    options.push([monsterX, monsterY + Math.sign(dy)])   // then vertical
+  else:
+    options.push([monsterX, monsterY + Math.sign(dy)])   // try vertical
+    options.push([monsterX + Math.sign(dx), monsterY])   // then horizontal
+- // fallback neighbor moves (up,down,left,right)
+- options.push([monsterX+1,monsterY]); options.push([monsterX-1,monsterY])
+- options.push([monsterX,monsterY+1]); options.push([monsterX,monsterY-1])
+- // pick first valid option that is inside bounds and is a path (maze[oy][ox]==1)
+- for each (ox,oy) in options:
+    if ox >= 0 && oy >= 0 && ox < cols && oy < rows:
+      if maze[oy][ox] == 1:
+         monsterX = ox; monsterY = oy; break
+
+// End game
+endGame(win):
+- gameOver = true
+- message = win ? "üèÜ You escaped!" : "üíÄ The monster caught you!"
+- render()
+
+// Render: show large emoji grid (player & monster as emoji)
+render():
+- Build a multiline string (use a fixed-width block or preformatted text) where each cell is:
+    if x==playerX && y==playerY ‚Üí "üßç"
+    else if x==monsterX && y==monsterY ‚Üí "üëπ"
+    else if x==exitX && y==exitY ‚Üí "üüß"   // exit neon orange
+    else if maze[y][x] == 0 ‚Üí "üü•"         // wall neon red
+    else ‚Üí "üü¶"                             // path neon blue
+- Display the grid in a large font-size (set container style to large/xx-large or use <pre> with font-size:32px) so tiles are visually big and readable.
+- Always display: Title, message, grid, controls (Up/Down/Left/Right), and a visible Restart button that calls initGame().
+- DO NOT display any debug lines or coordinate text.
+
+UI Buttons:
+- Up ‚Üí move("Up")
+- Down ‚Üí move("Down")
+- Left ‚Üí move("Left")
+- Right ‚Üí move("Right")
+- Restart ‚Üí initGame()
+
+Important notes:
+- Use the exact maze cell checks (maze[y][x]==1 means walkable).
+- Ensure initGame always places player, monster and exit on path cells.
+- Use a large font-size in the grid container so emoji squares appear big, not tiny.
+

# 2025-12-02 19:42:44.844958
+Title: Monster Chase Maze ‚Äî Emoji Grid (Fixed)
+Description: 10√ó10 neon maze. Player üßç and Monster üëπ shown as emoji, exit üüß. Big visible grid, restart always works. Monster chase logic fixed.
+
+Category: Game
+Style: Text + emoji grid, DOM-friendly.
+
+Persistent State:
+- maze (2D array)          // 0 = wall, 1 = path
+- rows = 10
+- cols = 10
+- playerX, playerY
+- monsterX, monsterY
+- exitX, exitY
+- moves, timeLeft
+- message
+- gameOver
+
+On App Load:
+Call initGame() automatically.
+
+initGame():
+- rows = 10; cols = 10
+- // create full walls
+- maze = new 2D array rows√ócols with all cells = 0
+- // carve a guaranteed path from (0,0) to (cols-1,rows-1)
+- x = 0; y = 0; maze[y][x] = 1
+- while x < cols-1 or y < rows-1:
+    if Math.random() < 0.5 and x < cols-1:
+      x += 1
+    else if y < rows-1:
+      y += 1
+    maze[y][x] = 1
+- // open extra random path cells so maze is not a straight corridor
+- for i from 0 to 40:
+    rx = floor(Math.random()*cols); ry = floor(Math.random()*rows)
+    maze[ry][rx] = 1
+- // choose start / monster / exit on path cells
+- playerX = 0; playerY = 0; // ensure maze[0][0] == 1
+- // find monster start: search for a path cell near bottom-right
+- monsterX = cols-1; monsterY = rows-1
+- if maze[monsterY][monsterX] == 0:
+    // find nearest path cell to bottom-right
+    for yy from rows-1 downto 0:
+      for xx from cols-1 downto 0:
+        if maze[yy][xx] == 1:
+           monsterX = xx; monsterY = yy; break loops
+- // set exit to a random path cell not overlapping player/monster
+- do:
+    exitX = floor(Math.random()*cols); exitY = floor(Math.random()*rows)
+  while maze[exitY][exitX] != 1 || (exitX==playerX && exitY==playerY) || (exitX==monsterX && exitY==monsterY)
+- moves = 0; timeLeft = 30; gameOver = false
+- message = "Escape the maze! Use buttons. Restart always available."
+- render()
+
+// Movement input
+move(dir):
+- if gameOver return
+- nx = playerX; ny = playerY
+- if dir=="Up" then ny -= 1
+- if dir=="Down" then ny += 1
+- if dir=="Left" then nx -= 1
+- if dir=="Right" then nx += 1
+- if nx < 0 || ny < 0 || nx >= cols || ny >= rows then return
+- if maze[ny][nx] == 0 then return
+- // valid: move player
+- playerX = nx; playerY = ny; moves += 1; timeLeft -= 1
+- // win check
+- if playerX==exitX && playerY==exitY: endGame(true); return
+- // monster moves after player
+- monsterMove()
+- // monster catches player?
+- if monsterX==playerX && monsterY==playerY: endGame(false); return
+- if timeLeft <= 0: endGame(false); return
+- render()
+
+// Monster movement (fixed logic)
+monsterMove():
+- if gameOver return
+- dx = playerX - monsterX; dy = playerY - monsterY
+- options = []
+- // prioritize reducing larger distance first (try horizontal then vertical or vice versa)
+- if Math.abs(dx) >= Math.abs(dy):
+    options.push([monsterX + Math.sign(dx), monsterY])   // try horizontal
+    options.push([monsterX, monsterY + Math.sign(dy)])   // then vertical
+  else:
+    options.push([monsterX, monsterY + Math.sign(dy)])   // try vertical
+    options.push([monsterX + Math.sign(dx), monsterY])   // then horizontal
+- // fallback neighbor moves (up,down,left,right)
+- options.push([monsterX+1,monsterY]); options.push([monsterX-1,monsterY])
+- options.push([monsterX,monsterY+1]); options.push([monsterX,monsterY-1])
+- // pick first valid option that is inside bounds and is a path (maze[oy][ox]==1)
+- for each (ox,oy) in options:
+    if ox >= 0 && oy >= 0 && ox < cols && oy < rows:
+      if maze[oy][ox] == 1:
+         monsterX = ox; monsterY = oy; break
+
+// End game
+endGame(win):
+- gameOver = true
+- message = win ? "üèÜ You escaped!" : "üíÄ The monster caught you!"
+- render()
+
+// Render: show large emoji grid (player & monster as emoji)
+render():
+- Build a multiline string (use a fixed-width block or preformatted text) where each cell is:
+    if x==playerX && y==playerY ‚Üí "üßç"
+    else if x==monsterX && y==monsterY ‚Üí "üëπ"
+    else if x==exitX && y==exitY ‚Üí "üüß"   // exit neon orange
+    else if maze[y][x] == 0 ‚Üí "üü•"         // wall neon red
+    else ‚Üí "üü¶"                             // path neon blue
+- Display the grid in a large font-size (set container style to large/xx-large or use <pre> with font-size:32px) so tiles are visually big and readable.
+- Always display: Title, message, grid, controls (Up/Down/Left/Right), and a visible Restart button that calls initGame().
+- DO NOT display any debug lines or coordinate text.
+
+UI Buttons:
+- Up ‚Üí move("Up")
+- Down ‚Üí move("Down")
+- Left ‚Üí move("Left")
+- Right ‚Üí move("Right")
+- Restart ‚Üí initGame()
+
+Important notes:
+- Use the exact maze cell checks (maze[y][x]==1 means walkable).
+- Ensure initGame always places player, monster and exit on path cells.
+- Use a large font-size in the grid container so emoji squares appear big, not tiny.
+

# 2025-12-02 22:30:06.475303
+Title: Monster Chase  Maze
+Description: Escape a maze while a monster hunts you. Player, monster, walls and exit are displayed correctly. Fully compatible with Base Mini App Factory.
+Category: Game
+
+Persistent State:
+- maze
+- rows
+- cols
+- playerX
+- playerY
+- monsterX
+- monsterY
+- exitX
+- exitY
+- message
+- gameOver
+
+On App Load:
+initGame()
+
+Functions:
+
+initGame():
+  rows = 10
+  cols = 10
+  gameOver = false
+  message = "Escape the maze!"
+
+  maze = []
+
+  // Create full wall grid
+  for (let y = 0; y < rows; y++) {
+    let row = []
+    for (let x = 0; x < cols; x++) {
+      row.push(1)
+    }
+    maze.push(row)
+  }
+
+  // Guaranteed path
+  let px = 0
+  let py = 0
+  maze[py][px] = 0
+
+  while (px !== cols - 1 || py !== rows - 1) {
+    if (Math.random() < 0.5 && px < cols - 1) {
+      px++
+    } else if (py < rows - 1) {
+      py++
+    }
+    maze[py][px] = 0
+  }
+
+  // Random openings
+  for (let i = 0; i < 40; i++) {
+    let rx = Math.floor(Math.random() * cols)
+    let ry = Math.floor(Math.random() * rows)
+    maze[ry][rx] = 0
+  }
+
+  // Start positions
+  playerX = 0
+  playerY = 0
+  exitX = cols - 1
+  exitY = rows - 1
+  monsterX = cols - 1
+  monsterY = rows - 2
+
+
+move(direction):
+  if (gameOver) return
+
+  let nx = playerX
+  let ny = playerY
+
+  if (direction === "Up") ny--
+  if (direction === "Down") ny++
+  if (direction === "Left") nx--
+  if (direction === "Right") nx++
+
+  if (nx < 0 || ny < 0 || nx >= cols || ny >= rows) return
+  if (maze[ny][nx] === 1) return
+
+  playerX = nx
+  playerY = ny
+
+  if (playerX === exitX && playerY === exitY) {
+    endGame(true)
+    return
+  }
+
+  monsterChase()
+
+
+monsterChase():
+  function sign(v) {
+    return v > 0 ? 1 : v < 0 ? -1 : 0
+  }
+
+  let dx = playerX - monsterX
+  let dy = playerY - monsterY
+
+  let options = []
+
+  if (Math.abs(dx) > Math.abs(dy)) {
+    options.push([monsterX + sign(dx), monsterY])
+    options.push([monsterX, monsterY + sign(dy)])
+  } else {
+    options.push([monsterX, monsterY + sign(dy)])
+    options.push([monsterX + sign(dx), monsterY])
+  }
+
+  // fallback moves
+  options.push([monsterX + 1, monsterY])
+  options.push([monsterX - 1, monsterY])
+  options.push([monsterX, monsterY + 1])
+  options.push([monsterX, monsterY - 1])
+
+  for (let op of options) {
+    let ox = op[0]
+    let oy = op[1]
+
+    if (ox >= 0 && oy >= 0 && ox < cols && oy < rows) {
+      if (maze[oy][ox] === 0) {
+        monsterX = ox
+        monsterY = oy
+        break
+      }
+    }
+  }
+
+  if (monsterX === playerX && monsterY === playerY) {
+    endGame(false)
+  }
+
+
+endGame(win):
+  gameOver = true
+  message = win ? "üèÜ You escaped!" : "üíÄ The monster caught you!"
+
+
+Render:
+  let grid = ""
+
+  for (let y = 0; y < rows; y++) {
+    let row = ""
+    for (let x = 0; x < cols; x++) {
+
+      if (x === playerX && y === playerY) {
+        row += "üßç"
+      }
+      else if (x === monsterX && y === monsterY) {
+        row += "üëπ"
+      }
+      else if (x === exitX && y === exitY) {
+        row += "üüß"
+      }
+      else if (maze[y][x] === 1) {
+        row += "üü•"
+      }
+      else {
+        row += "üü¶"
+      }
+    }
+    grid += row + "\n"
+  }
+
+  Display:
+  - "Monster Chase Maze"
+  - message
+  - grid
+
+  If (!gameOver):
+    Buttons:
+      Up ‚Üí move("Up")
+      Down ‚Üí move("Down")
+      Left ‚Üí move("Left")
+      Right ‚Üí move("Right")
+
+  Else:
+    Buttons:
+      Restart ‚Üí initGame()
+

# 2025-12-02 22:30:06.476596
+Title: Monster Chase  Maze
+Description: Escape a maze while a monster hunts you. Player, monster, walls and exit are displayed correctly. Fully compatible with Base Mini App Factory.
+Category: Game
+
+Persistent State:
+- maze
+- rows
+- cols
+- playerX
+- playerY
+- monsterX
+- monsterY
+- exitX
+- exitY
+- message
+- gameOver
+
+On App Load:
+initGame()
+
+Functions:
+
+initGame():
+  rows = 10
+  cols = 10
+  gameOver = false
+  message = "Escape the maze!"
+
+  maze = []
+
+  // Create full wall grid
+  for (let y = 0; y < rows; y++) {
+    let row = []
+    for (let x = 0; x < cols; x++) {
+      row.push(1)
+    }
+    maze.push(row)
+  }
+
+  // Guaranteed path
+  let px = 0
+  let py = 0
+  maze[py][px] = 0
+
+  while (px !== cols - 1 || py !== rows - 1) {
+    if (Math.random() < 0.5 && px < cols - 1) {
+      px++
+    } else if (py < rows - 1) {
+      py++
+    }
+    maze[py][px] = 0
+  }
+
+  // Random openings
+  for (let i = 0; i < 40; i++) {
+    let rx = Math.floor(Math.random() * cols)
+    let ry = Math.floor(Math.random() * rows)
+    maze[ry][rx] = 0
+  }
+
+  // Start positions
+  playerX = 0
+  playerY = 0
+  exitX = cols - 1
+  exitY = rows - 1
+  monsterX = cols - 1
+  monsterY = rows - 2
+
+
+move(direction):
+  if (gameOver) return
+
+  let nx = playerX
+  let ny = playerY
+
+  if (direction === "Up") ny--
+  if (direction === "Down") ny++
+  if (direction === "Left") nx--
+  if (direction === "Right") nx++
+
+  if (nx < 0 || ny < 0 || nx >= cols || ny >= rows) return
+  if (maze[ny][nx] === 1) return
+
+  playerX = nx
+  playerY = ny
+
+  if (playerX === exitX && playerY === exitY) {
+    endGame(true)
+    return
+  }
+
+  monsterChase()
+
+
+monsterChase():
+  function sign(v) {
+    return v > 0 ? 1 : v < 0 ? -1 : 0
+  }
+
+  let dx = playerX - monsterX
+  let dy = playerY - monsterY
+
+  let options = []
+
+  if (Math.abs(dx) > Math.abs(dy)) {
+    options.push([monsterX + sign(dx), monsterY])
+    options.push([monsterX, monsterY + sign(dy)])
+  } else {
+    options.push([monsterX, monsterY + sign(dy)])
+    options.push([monsterX + sign(dx), monsterY])
+  }
+
+  // fallback moves
+  options.push([monsterX + 1, monsterY])
+  options.push([monsterX - 1, monsterY])
+  options.push([monsterX, monsterY + 1])
+  options.push([monsterX, monsterY - 1])
+
+  for (let op of options) {
+    let ox = op[0]
+    let oy = op[1]
+
+    if (ox >= 0 && oy >= 0 && ox < cols && oy < rows) {
+      if (maze[oy][ox] === 0) {
+        monsterX = ox
+        monsterY = oy
+        break
+      }
+    }
+  }
+
+  if (monsterX === playerX && monsterY === playerY) {
+    endGame(false)
+  }
+
+
+endGame(win):
+  gameOver = true
+  message = win ? "üèÜ You escaped!" : "üíÄ The monster caught you!"
+
+
+Render:
+  let grid = ""
+
+  for (let y = 0; y < rows; y++) {
+    let row = ""
+    for (let x = 0; x < cols; x++) {
+
+      if (x === playerX && y === playerY) {
+        row += "üßç"
+      }
+      else if (x === monsterX && y === monsterY) {
+        row += "üëπ"
+      }
+      else if (x === exitX && y === exitY) {
+        row += "üüß"
+      }
+      else if (maze[y][x] === 1) {
+        row += "üü•"
+      }
+      else {
+        row += "üü¶"
+      }
+    }
+    grid += row + "\n"
+  }
+
+  Display:
+  - "Monster Chase Maze"
+  - message
+  - grid
+
+  If (!gameOver):
+    Buttons:
+      Up ‚Üí move("Up")
+      Down ‚Üí move("Down")
+      Left ‚Üí move("Left")
+      Right ‚Üí move("Right")
+
+  Else:
+    Buttons:
+      Restart ‚Üí initGame()
+

# 2025-12-03 08:41:08.330351
+Title: Monster Chase Maze ‚Äî Emoji Grid (Fixed)
+Description: 10√ó10 neon maze. Player üßç and Monster üëπ shown as emoji, exit üüß. Big visible grid, restart always works. Monster chase logic fixed.
+
+Category: Game
+Style: Text + emoji grid, DOM-friendly.
+
+Persistent State:
+- maze (2D array)          // 0 = wall, 1 = path
+- rows = 10
+- cols = 10
+- playerX, playerY
+- monsterX, monsterY
+- exitX, exitY
+- moves, timeLeft
+- message
+- gameOver
+
+On App Load:
+Call initGame() automatically.
+
+initGame():
+- rows = 10; cols = 10
+- // create full walls
+- maze = new 2D array rows√ócols with all cells = 0
+- // carve a guaranteed path from (0,0) to (cols-1,rows-1)
+- x = 0; y = 0; maze[y][x] = 1
+- while x < cols-1 or y < rows-1:
+    if Math.random() < 0.5 and x < cols-1:
+      x += 1
+    else if y < rows-1:
+      y += 1
+    maze[y][x] = 1
+- // open extra random path cells so maze is not a straight corridor
+- for i from 0 to 40:
+    rx = floor(Math.random()*cols); ry = floor(Math.random()*rows)
+    maze[ry][rx] = 1
+- // choose start / monster / exit on path cells
+- playerX = 0; playerY = 0; // ensure maze[0][0] == 1
+- // find monster start: search for a path cell near bottom-right
+- monsterX = cols-1; monsterY = rows-1
+- if maze[monsterY][monsterX] == 0:
+    // find nearest path cell to bottom-right
+    for yy from rows-1 downto 0:
+      for xx from cols-1 downto 0:
+        if maze[yy][xx] == 1:
+           monsterX = xx; monsterY = yy; break loops
+- // set exit to a random path cell not overlapping player/monster
+- do:
+    exitX = floor(Math.random()*cols); exitY = floor(Math.random()*rows)
+  while maze[exitY][exitX] != 1 || (exitX==playerX && exitY==playerY) || (exitX==monsterX && exitY==monsterY)
+- moves = 0; timeLeft = 30; gameOver = false
+- message = "Escape the maze! Use buttons. Restart always available."
+- render()
+
+// Movement input
+move(dir):
+- if gameOver return
+- nx = playerX; ny = playerY
+- if dir=="Up" then ny -= 1
+- if dir=="Down" then ny += 1
+- if dir=="Left" then nx -= 1
+- if dir=="Right" then nx += 1
+- if nx < 0 || ny < 0 || nx >= cols || ny >= rows then return
+- if maze[ny][nx] == 0 then return
+- // valid: move player
+- playerX = nx; playerY = ny; moves += 1; timeLeft -= 1
+- // win check
+- if playerX==exitX && playerY==exitY: endGame(true); return
+- // monster moves after player
+- monsterMove()
+- // monster catches player?
+- if monsterX==playerX && monsterY==playerY: endGame(false); return
+- if timeLeft <= 0: endGame(false); return
+- render()
+
+// Monster movement (fixed logic)
+monsterMove():
+- if gameOver return
+- dx = playerX - monsterX; dy = playerY - monsterY
+- options = []
+- // prioritize reducing larger distance first (try horizontal then vertical or vice versa)
+- if Math.abs(dx) >= Math.abs(dy):
+    options.push([monsterX + Math.sign(dx), monsterY])   // try horizontal
+    options.push([monsterX, monsterY + Math.sign(dy)])   // then vertical
+  else:
+    options.push([monsterX, monsterY + Math.sign(dy)])   // try vertical
+    options.push([monsterX + Math.sign(dx), monsterY])   // then horizontal
+- // fallback neighbor moves (up,down,left,right)
+- options.push([monsterX+1,monsterY]); options.push([monsterX-1,monsterY])
+- options.push([monsterX,monsterY+1]); options.push([monsterX,monsterY-1])
+- // pick first valid option that is inside bounds and is a path (maze[oy][ox]==1)
+- for each (ox,oy) in options:
+    if ox >= 0 && oy >= 0 && ox < cols && oy < rows:
+      if maze[oy][ox] == 1:
+         monsterX = ox; monsterY = oy; break
+
+// End game
+endGame(win):
+- gameOver = true
+- message = win ? "üèÜ You escaped!" : "üíÄ The monster caught you!"
+- render()
+
+// Render: show large emoji grid (player & monster as emoji)
+render():
+- Build a multiline string (use a fixed-width block or preformatted text) where each cell is:
+    if x==playerX && y==playerY ‚Üí "üßç"
+    else if x==monsterX && y==monsterY ‚Üí "üëπ"
+    else if x==exitX && y==exitY ‚Üí "üüß"   // exit neon orange
+    else if maze[y][x] == 0 ‚Üí "üü•"         // wall neon red
+    else ‚Üí "üü¶"                             // path neon blue
+- Display the grid in a large font-size (set container style to large/xx-large or use <pre> with font-size:32px) so tiles are visually big and readable.
+- Always display: Title, message, grid, controls (Up/Down/Left/Right), and a visible Restart button that calls initGame().
+- DO NOT display any debug lines or coordinate text.
+
+UI Buttons:
+- Up ‚Üí move("Up")
+- Down ‚Üí move("Down")
+- Left ‚Üí move("Left")
+- Right ‚Üí move("Right")
+- Restart ‚Üí initGame()
+
+Important notes:
+- Use the exact maze cell checks (maze[y][x]==1 means walkable).
+- Ensure initGame always places player, monster and exit on path cells.
+- Use a large font-size in the grid container so emoji squares appear big, not tiny.
+

# 2025-12-03 08:41:08.330934
+Title: Monster Chase Maze ‚Äî Emoji Grid (Fixed)
+Description: 10√ó10 neon maze. Player üßç and Monster üëπ shown as emoji, exit üüß. Big visible grid, restart always works. Monster chase logic fixed.
+
+Category: Game
+Style: Text + emoji grid, DOM-friendly.
+
+Persistent State:
+- maze (2D array)          // 0 = wall, 1 = path
+- rows = 10
+- cols = 10
+- playerX, playerY
+- monsterX, monsterY
+- exitX, exitY
+- moves, timeLeft
+- message
+- gameOver
+
+On App Load:
+Call initGame() automatically.
+
+initGame():
+- rows = 10; cols = 10
+- // create full walls
+- maze = new 2D array rows√ócols with all cells = 0
+- // carve a guaranteed path from (0,0) to (cols-1,rows-1)
+- x = 0; y = 0; maze[y][x] = 1
+- while x < cols-1 or y < rows-1:
+    if Math.random() < 0.5 and x < cols-1:
+      x += 1
+    else if y < rows-1:
+      y += 1
+    maze[y][x] = 1
+- // open extra random path cells so maze is not a straight corridor
+- for i from 0 to 40:
+    rx = floor(Math.random()*cols); ry = floor(Math.random()*rows)
+    maze[ry][rx] = 1
+- // choose start / monster / exit on path cells
+- playerX = 0; playerY = 0; // ensure maze[0][0] == 1
+- // find monster start: search for a path cell near bottom-right
+- monsterX = cols-1; monsterY = rows-1
+- if maze[monsterY][monsterX] == 0:
+    // find nearest path cell to bottom-right
+    for yy from rows-1 downto 0:
+      for xx from cols-1 downto 0:
+        if maze[yy][xx] == 1:
+           monsterX = xx; monsterY = yy; break loops
+- // set exit to a random path cell not overlapping player/monster
+- do:
+    exitX = floor(Math.random()*cols); exitY = floor(Math.random()*rows)
+  while maze[exitY][exitX] != 1 || (exitX==playerX && exitY==playerY) || (exitX==monsterX && exitY==monsterY)
+- moves = 0; timeLeft = 30; gameOver = false
+- message = "Escape the maze! Use buttons. Restart always available."
+- render()
+
+// Movement input
+move(dir):
+- if gameOver return
+- nx = playerX; ny = playerY
+- if dir=="Up" then ny -= 1
+- if dir=="Down" then ny += 1
+- if dir=="Left" then nx -= 1
+- if dir=="Right" then nx += 1
+- if nx < 0 || ny < 0 || nx >= cols || ny >= rows then return
+- if maze[ny][nx] == 0 then return
+- // valid: move player
+- playerX = nx; playerY = ny; moves += 1; timeLeft -= 1
+- // win check
+- if playerX==exitX && playerY==exitY: endGame(true); return
+- // monster moves after player
+- monsterMove()
+- // monster catches player?
+- if monsterX==playerX && monsterY==playerY: endGame(false); return
+- if timeLeft <= 0: endGame(false); return
+- render()
+
+// Monster movement (fixed logic)
+monsterMove():
+- if gameOver return
+- dx = playerX - monsterX; dy = playerY - monsterY
+- options = []
+- // prioritize reducing larger distance first (try horizontal then vertical or vice versa)
+- if Math.abs(dx) >= Math.abs(dy):
+    options.push([monsterX + Math.sign(dx), monsterY])   // try horizontal
+    options.push([monsterX, monsterY + Math.sign(dy)])   // then vertical
+  else:
+    options.push([monsterX, monsterY + Math.sign(dy)])   // try vertical
+    options.push([monsterX + Math.sign(dx), monsterY])   // then horizontal
+- // fallback neighbor moves (up,down,left,right)
+- options.push([monsterX+1,monsterY]); options.push([monsterX-1,monsterY])
+- options.push([monsterX,monsterY+1]); options.push([monsterX,monsterY-1])
+- // pick first valid option that is inside bounds and is a path (maze[oy][ox]==1)
+- for each (ox,oy) in options:
+    if ox >= 0 && oy >= 0 && ox < cols && oy < rows:
+      if maze[oy][ox] == 1:
+         monsterX = ox; monsterY = oy; break
+
+// End game
+endGame(win):
+- gameOver = true
+- message = win ? "üèÜ You escaped!" : "üíÄ The monster caught you!"
+- render()
+
+// Render: show large emoji grid (player & monster as emoji)
+render():
+- Build a multiline string (use a fixed-width block or preformatted text) where each cell is:
+    if x==playerX && y==playerY ‚Üí "üßç"
+    else if x==monsterX && y==monsterY ‚Üí "üëπ"
+    else if x==exitX && y==exitY ‚Üí "üüß"   // exit neon orange
+    else if maze[y][x] == 0 ‚Üí "üü•"         // wall neon red
+    else ‚Üí "üü¶"                             // path neon blue
+- Display the grid in a large font-size (set container style to large/xx-large or use <pre> with font-size:32px) so tiles are visually big and readable.
+- Always display: Title, message, grid, controls (Up/Down/Left/Right), and a visible Restart button that calls initGame().
+- DO NOT display any debug lines or coordinate text.
+
+UI Buttons:
+- Up ‚Üí move("Up")
+- Down ‚Üí move("Down")
+- Left ‚Üí move("Left")
+- Right ‚Üí move("Right")
+- Restart ‚Üí initGame()
+
+Important notes:
+- Use the exact maze cell checks (maze[y][x]==1 means walkable).
+- Ensure initGame always places player, monster and exit on path cells.
+- Use a large font-size in the grid container so emoji squares appear big, not tiny.
+

# 2025-12-03 09:17:30.946694
+Title: Monster Chase Maze ‚Äî Emoji Grid (Fixed)
+Description: 10√ó10 neon maze. Player üßç and Monster üëπ shown as emoji, exit üüß. Big visible grid, restart always works. Monster chase logic fixed.
+
+Category: Game
+Style: Text + emoji grid, DOM-friendly.
+
+Persistent State:
+- maze (2D array)          // 0 = wall, 1 = path
+- rows = 10
+- cols = 10
+- playerX, playerY
+- monsterX, monsterY
+- exitX, exitY
+- moves, timeLeft
+- message
+- gameOver
+
+On App Load:
+Call initGame() automatically.
+
+initGame():
+- rows = 10; cols = 10
+- // create full walls
+- maze = new 2D array rows√ócols with all cells = 0
+- // carve a guaranteed path from (0,0) to (cols-1,rows-1)
+- x = 0; y = 0; maze[y][x] = 1
+- while x < cols-1 or y < rows-1:
+    if Math.random() < 0.5 and x < cols-1:
+      x += 1
+    else if y < rows-1:
+      y += 1
+    maze[y][x] = 1
+- // open extra random path cells so maze is not a straight corridor
+- for i from 0 to 40:
+    rx = floor(Math.random()*cols); ry = floor(Math.random()*rows)
+    maze[ry][rx] = 1
+- // choose start / monster / exit on path cells
+- playerX = 0; playerY = 0; // ensure maze[0][0] == 1
+- // find monster start: search for a path cell near bottom-right
+- monsterX = cols-1; monsterY = rows-1
+- if maze[monsterY][monsterX] == 0:
+    // find nearest path cell to bottom-right
+    for yy from rows-1 downto 0:
+      for xx from cols-1 downto 0:
+        if maze[yy][xx] == 1:
+           monsterX = xx; monsterY = yy; break loops
+- // set exit to a random path cell not overlapping player/monster
+- do:
+    exitX = floor(Math.random()*cols); exitY = floor(Math.random()*rows)
+  while maze[exitY][exitX] != 1 || (exitX==playerX && exitY==playerY) || (exitX==monsterX && exitY==monsterY)
+- moves = 0; timeLeft = 30; gameOver = false
+- message = "Escape the maze! Use buttons. Restart always available."
+- render()
+
+// Movement input
+move(dir):
+- if gameOver return
+- nx = playerX; ny = playerY
+- if dir=="Up" then ny -= 1
+- if dir=="Down" then ny += 1
+- if dir=="Left" then nx -= 1
+- if dir=="Right" then nx += 1
+- if nx < 0 || ny < 0 || nx >= cols || ny >= rows then return
+- if maze[ny][nx] == 0 then return
+- // valid: move player
+- playerX = nx; playerY = ny; moves += 1; timeLeft -= 1
+- // win check
+- if playerX==exitX && playerY==exitY: endGame(true); return
+- // monster moves after player
+- monsterMove()
+- // monster catches player?
+- if monsterX==playerX && monsterY==playerY: endGame(false); return
+- if timeLeft <= 0: endGame(false); return
+- render()
+
+// Monster movement (fixed logic)
+monsterMove():
+- if gameOver return
+- dx = playerX - monsterX; dy = playerY - monsterY
+- options = []
+- // prioritize reducing larger distance first (try horizontal then vertical or vice versa)
+- if Math.abs(dx) >= Math.abs(dy):
+    options.push([monsterX + Math.sign(dx), monsterY])   // try horizontal
+    options.push([monsterX, monsterY + Math.sign(dy)])   // then vertical
+  else:
+    options.push([monsterX, monsterY + Math.sign(dy)])   // try vertical
+    options.push([monsterX + Math.sign(dx), monsterY])   // then horizontal
+- // fallback neighbor moves (up,down,left,right)
+- options.push([monsterX+1,monsterY]); options.push([monsterX-1,monsterY])
+- options.push([monsterX,monsterY+1]); options.push([monsterX,monsterY-1])
+- // pick first valid option that is inside bounds and is a path (maze[oy][ox]==1)
+- for each (ox,oy) in options:
+    if ox >= 0 && oy >= 0 && ox < cols && oy < rows:
+      if maze[oy][ox] == 1:
+         monsterX = ox; monsterY = oy; break
+
+// End game
+endGame(win):
+- gameOver = true
+- message = win ? "üèÜ You escaped!" : "üíÄ The monster caught you!"
+- render()
+
+// Render: show large emoji grid (player & monster as emoji)
+render():
+- Build a multiline string (use a fixed-width block or preformatted text) where each cell is:
+    if x==playerX && y==playerY ‚Üí "üßç"
+    else if x==monsterX && y==monsterY ‚Üí "üëπ"
+    else if x==exitX && y==exitY ‚Üí "üüß"   // exit neon orange
+    else if maze[y][x] == 0 ‚Üí "üü•"         // wall neon red
+    else ‚Üí "üü¶"                             // path neon blue
+- Display the grid in a large font-size (set container style to large/xx-large or use <pre> with font-size:32px) so tiles are visually big and readable.
+- Always display: Title, message, grid, controls (Up/Down/Left/Right), and a visible Restart button that calls initGame().
+- DO NOT display any debug lines or coordinate text.
+
+UI Buttons:
+- Up ‚Üí move("Up")
+- Down ‚Üí move("Down")
+- Left ‚Üí move("Left")
+- Right ‚Üí move("Right")
+- Restart ‚Üí initGame()
+
+Important notes: 
+player is never blocked at start.
+- guarantees exit and monster spawn on reachable path tiles; therefore restarted mazes will always be solvable and monster will have space to move.
+- MonsterMove logic examines all neighbors and picks the neighbor that reduces distance; fallback neighbor scan prevents being stuck.
+- Keep maze cell check consistent: maze[y][x] == 1 means walkable.
+- Use the exact maze cell checks (maze[y][x]==1 means walkable).
+- Ensure initGame always place

# 2025-12-03 09:17:30.948300
+Title: Monster Chase Maze ‚Äî Emoji Grid (Fixed)
+Description: 10√ó10 neon maze. Player üßç and Monster üëπ shown as emoji, exit üüß. Big visible grid, restart always works. Monster chase logic fixed.
+
+Category: Game
+Style: Text + emoji grid, DOM-friendly.
+
+Persistent State:
+- maze (2D array)          // 0 = wall, 1 = path
+- rows = 10
+- cols = 10
+- playerX, playerY
+- monsterX, monsterY
+- exitX, exitY
+- moves, timeLeft
+- message
+- gameOver
+
+On App Load:
+Call initGame() automatically.
+
+initGame():
+- rows = 10; cols = 10
+- // create full walls
+- maze = new 2D array rows√ócols with all cells = 0
+- // carve a guaranteed path from (0,0) to (cols-1,rows-1)
+- x = 0; y = 0; maze[y][x] = 1
+- while x < cols-1 or y < rows-1:
+    if Math.random() < 0.5 and x < cols-1:
+      x += 1
+    else if y < rows-1:
+      y += 1
+    maze[y][x] = 1
+- // open extra random path cells so maze is not a straight corridor
+- for i from 0 to 40:
+    rx = floor(Math.random()*cols); ry = floor(Math.random()*rows)
+    maze[ry][rx] = 1
+- // choose start / monster / exit on path cells
+- playerX = 0; playerY = 0; // ensure maze[0][0] == 1
+- // find monster start: search for a path cell near bottom-right
+- monsterX = cols-1; monsterY = rows-1
+- if maze[monsterY][monsterX] == 0:
+    // find nearest path cell to bottom-right
+    for yy from rows-1 downto 0:
+      for xx from cols-1 downto 0:
+        if maze[yy][xx] == 1:
+           monsterX = xx; monsterY = yy; break loops
+- // set exit to a random path cell not overlapping player/monster
+- do:
+    exitX = floor(Math.random()*cols); exitY = floor(Math.random()*rows)
+  while maze[exitY][exitX] != 1 || (exitX==playerX && exitY==playerY) || (exitX==monsterX && exitY==monsterY)
+- moves = 0; timeLeft = 30; gameOver = false
+- message = "Escape the maze! Use buttons. Restart always available."
+- render()
+
+// Movement input
+move(dir):
+- if gameOver return
+- nx = playerX; ny = playerY
+- if dir=="Up" then ny -= 1
+- if dir=="Down" then ny += 1
+- if dir=="Left" then nx -= 1
+- if dir=="Right" then nx += 1
+- if nx < 0 || ny < 0 || nx >= cols || ny >= rows then return
+- if maze[ny][nx] == 0 then return
+- // valid: move player
+- playerX = nx; playerY = ny; moves += 1; timeLeft -= 1
+- // win check
+- if playerX==exitX && playerY==exitY: endGame(true); return
+- // monster moves after player
+- monsterMove()
+- // monster catches player?
+- if monsterX==playerX && monsterY==playerY: endGame(false); return
+- if timeLeft <= 0: endGame(false); return
+- render()
+
+// Monster movement (fixed logic)
+monsterMove():
+- if gameOver return
+- dx = playerX - monsterX; dy = playerY - monsterY
+- options = []
+- // prioritize reducing larger distance first (try horizontal then vertical or vice versa)
+- if Math.abs(dx) >= Math.abs(dy):
+    options.push([monsterX + Math.sign(dx), monsterY])   // try horizontal
+    options.push([monsterX, monsterY + Math.sign(dy)])   // then vertical
+  else:
+    options.push([monsterX, monsterY + Math.sign(dy)])   // try vertical
+    options.push([monsterX + Math.sign(dx), monsterY])   // then horizontal
+- // fallback neighbor moves (up,down,left,right)
+- options.push([monsterX+1,monsterY]); options.push([monsterX-1,monsterY])
+- options.push([monsterX,monsterY+1]); options.push([monsterX,monsterY-1])
+- // pick first valid option that is inside bounds and is a path (maze[oy][ox]==1)
+- for each (ox,oy) in options:
+    if ox >= 0 && oy >= 0 && ox < cols && oy < rows:
+      if maze[oy][ox] == 1:
+         monsterX = ox; monsterY = oy; break
+
+// End game
+endGame(win):
+- gameOver = true
+- message = win ? "üèÜ You escaped!" : "üíÄ The monster caught you!"
+- render()
+
+// Render: show large emoji grid (player & monster as emoji)
+render():
+- Build a multiline string (use a fixed-width block or preformatted text) where each cell is:
+    if x==playerX && y==playerY ‚Üí "üßç"
+    else if x==monsterX && y==monsterY ‚Üí "üëπ"
+    else if x==exitX && y==exitY ‚Üí "üüß"   // exit neon orange
+    else if maze[y][x] == 0 ‚Üí "üü•"         // wall neon red
+    else ‚Üí "üü¶"                             // path neon blue
+- Display the grid in a large font-size (set container style to large/xx-large or use <pre> with font-size:32px) so tiles are visually big and readable.
+- Always display: Title, message, grid, controls (Up/Down/Left/Right), and a visible Restart button that calls initGame().
+- DO NOT display any debug lines or coordinate text.
+
+UI Buttons:
+- Up ‚Üí move("Up")
+- Down ‚Üí move("Down")
+- Left ‚Üí move("Left")
+- Right ‚Üí move("Right")
+- Restart ‚Üí initGame()
+
+Important notes: 
+player is never blocked at start.
+- guarantees exit and monster spawn on reachable path tiles; therefore restarted mazes will always be solvable and monster will have space to move.
+- MonsterMove logic examines all neighbors and picks the neighbor that reduces distance; fallback neighbor scan prevents being stuck.
+- Keep maze cell check consistent: maze[y][x] == 1 means walkable.
+- Use the exact maze cell checks (maze[y][x]==1 means walkable).
+- Ensure initGame always place

# 2025-12-03 09:37:02.878735
+Title: Monster Chase Maze ‚Äî Emoji Grid (Fixed)
+Description: 10√ó10 neon maze. Player üßç and Monster üëπ shown as emoji, exit üüß. Big visible grid, restart always works. Monster chase logic fixed.
+
+Category: Game
+Style: Text + emoji grid, DOM-friendly.
+
+Persistent State:
+- maze (2D array)          // 0 = wall, 1 = path
+- rows = 10
+- cols = 10
+- playerX, playerY
+- monsterX, monsterY
+- exitX, exitY
+- moves, timeLeft
+- message
+- gameOver
+
+On App Load:
+Call initGame() automatically.
+
+initGame():
+- rows = 10; cols = 10
+- // create full walls
+- maze = new 2D array rows√ócols with all cells = 0
+- // carve a guaranteed path from (0,0) to (cols-1,rows-1)
+- x = 0; y = 0; maze[y][x] = 1
+- while x < cols-1 or y < rows-1:
+    if Math.random() < 0.5 and x < cols-1:
+      x += 1
+    else if y < rows-1:
+      y += 1
+    maze[y][x] = 1
+- // open extra random path cells so maze is not a straight corridor
+- for i from 0 to 40:
+    rx = floor(Math.random()*cols); ry = floor(Math.random()*rows)
+    maze[ry][rx] = 1
+- // choose start / monster / exit on path cells
+- playerX = 0; playerY = 0; // ensure maze[0][0] == 1
+- // find monster start: search for a path cell near bottom-right
+- monsterX = cols-1; monsterY = rows-1
+- if maze[monsterY][monsterX] == 0:
+    // find nearest path cell to bottom-right
+    for yy from rows-1 downto 0:
+      for xx from cols-1 downto 0:
+        if maze[yy][xx] == 1:
+           monsterX = xx; monsterY = yy; break loops
+- // set exit to a random path cell not overlapping player/monster
+- do:
+    exitX = floor(Math.random()*cols); exitY = floor(Math.random()*rows)
+  while maze[exitY][exitX] != 1 || (exitX==playerX && exitY==playerY) || (exitX==monsterX && exitY==monsterY)
+- moves = 0; timeLeft = 30; gameOver = false
+- message = "Escape the maze! Use buttons. Restart always available."
+- render()
+
+// Movement input
+move(dir):
+- if gameOver return
+- nx = playerX; ny = playerY
+- if dir=="Up" then ny -= 1
+- if dir=="Down" then ny += 1
+- if dir=="Left" then nx -= 1
+- if dir=="Right" then nx += 1
+- if nx < 0 || ny < 0 || nx >= cols || ny >= rows then return
+- if maze[ny][nx] == 0 then return
+- // valid: move player
+- playerX = nx; playerY = ny; moves += 1; timeLeft -= 1
+- // win check
+- if playerX==exitX && playerY==exitY: endGame(true); return
+- // monster moves after player
+- monsterMove()
+- // monster catches player?
+- if monsterX==playerX && monsterY==playerY: endGame(false); return
+- if timeLeft <= 0: endGame(false); return
+- render()
+
+// Monster movement (fixed logic)
+monsterMove():
+- if gameOver return
+- dx = playerX - monsterX; dy = playerY - monsterY
+- options = []
+- // prioritize reducing larger distance first (try horizontal then vertical or vice versa)
+- if Math.abs(dx) >= Math.abs(dy):
+    options.push([monsterX + Math.sign(dx), monsterY])   // try horizontal
+    options.push([monsterX, monsterY + Math.sign(dy)])   // then vertical
+  else:
+    options.push([monsterX, monsterY + Math.sign(dy)])   // try vertical
+    options.push([monsterX + Math.sign(dx), monsterY])   // then horizontal
+- // fallback neighbor moves (up,down,left,right)
+- options.push([monsterX+1,monsterY]); options.push([monsterX-1,monsterY])
+- options.push([monsterX,monsterY+1]); options.push([monsterX,monsterY-1])
+- // pick first valid option that is inside bounds and is a path (maze[oy][ox]==1)
+- for each (ox,oy) in options:
+    if ox >= 0 && oy >= 0 && ox < cols && oy < rows:
+      if maze[oy][ox] == 1:
+         monsterX = ox; monsterY = oy; break
+
+// End game
+endGame(win):
+- gameOver = true
+- message = win ? "üèÜ You escaped!" : "üíÄ The monster caught you!"
+- render()
+
+// Render: show large emoji grid (player & monster as emoji)
+render():
+- Build a multiline string (use a fixed-width block or preformatted text) where each cell is:
+    if x==playerX && y==playerY ‚Üí "üßç"
+    else if x==monsterX && y==monsterY ‚Üí "üëπ"
+    else if x==exitX && y==exitY ‚Üí "üüß"   // exit neon orange
+    else if maze[y][x] == 0 ‚Üí "üü•"         // wall neon red
+    else ‚Üí "üü¶"                             // path neon blue
+- Display the grid in a large font-size (set container style to large/xx-large or use <pre> with font-size:32px) so tiles are visually big and readable.
+- Always display: Title, message, grid, controls (Up/Down/Left/Right), and a visible Restart button that calls initGame().
+- DO NOT display any debug lines or coordinate text.
+
+UI Buttons:
+- Up ‚Üí move("Up")
+- Down ‚Üí move("Down")
+- Left ‚Üí move("Left")
+- Right ‚Üí move("Right")
+- Restart ‚Üí initGame()
+
+Important notes: 
+- exit must not be blocked by walls
+- player is never blocked at start.
+- monster is never blocked
+-  guarantees exit and monster spawn on reachable path tiles; therefore restarted mazes will always be solvable and monster will have space to move..
+- MonsterMove logic examines all neighbors and picks the neighbor that reduces distance; fallback neighbor scan prevents being stuck.
+- Keep maze cell check consistent: maze[y][x] == 1 means walkable. 
+- Use the exact maze cell checks (maze[y][x]==1 means walkable)

# 2025-12-03 09:37:02.879528
+Title: Monster Chase Maze ‚Äî Emoji Grid (Fixed)
+Description: 10√ó10 neon maze. Player üßç and Monster üëπ shown as emoji, exit üüß. Big visible grid, restart always works. Monster chase logic fixed.
+
+Category: Game
+Style: Text + emoji grid, DOM-friendly.
+
+Persistent State:
+- maze (2D array)          // 0 = wall, 1 = path
+- rows = 10
+- cols = 10
+- playerX, playerY
+- monsterX, monsterY
+- exitX, exitY
+- moves, timeLeft
+- message
+- gameOver
+
+On App Load:
+Call initGame() automatically.
+
+initGame():
+- rows = 10; cols = 10
+- // create full walls
+- maze = new 2D array rows√ócols with all cells = 0
+- // carve a guaranteed path from (0,0) to (cols-1,rows-1)
+- x = 0; y = 0; maze[y][x] = 1
+- while x < cols-1 or y < rows-1:
+    if Math.random() < 0.5 and x < cols-1:
+      x += 1
+    else if y < rows-1:
+      y += 1
+    maze[y][x] = 1
+- // open extra random path cells so maze is not a straight corridor
+- for i from 0 to 40:
+    rx = floor(Math.random()*cols); ry = floor(Math.random()*rows)
+    maze[ry][rx] = 1
+- // choose start / monster / exit on path cells
+- playerX = 0; playerY = 0; // ensure maze[0][0] == 1
+- // find monster start: search for a path cell near bottom-right
+- monsterX = cols-1; monsterY = rows-1
+- if maze[monsterY][monsterX] == 0:
+    // find nearest path cell to bottom-right
+    for yy from rows-1 downto 0:
+      for xx from cols-1 downto 0:
+        if maze[yy][xx] == 1:
+           monsterX = xx; monsterY = yy; break loops
+- // set exit to a random path cell not overlapping player/monster
+- do:
+    exitX = floor(Math.random()*cols); exitY = floor(Math.random()*rows)
+  while maze[exitY][exitX] != 1 || (exitX==playerX && exitY==playerY) || (exitX==monsterX && exitY==monsterY)
+- moves = 0; timeLeft = 30; gameOver = false
+- message = "Escape the maze! Use buttons. Restart always available."
+- render()
+
+// Movement input
+move(dir):
+- if gameOver return
+- nx = playerX; ny = playerY
+- if dir=="Up" then ny -= 1
+- if dir=="Down" then ny += 1
+- if dir=="Left" then nx -= 1
+- if dir=="Right" then nx += 1
+- if nx < 0 || ny < 0 || nx >= cols || ny >= rows then return
+- if maze[ny][nx] == 0 then return
+- // valid: move player
+- playerX = nx; playerY = ny; moves += 1; timeLeft -= 1
+- // win check
+- if playerX==exitX && playerY==exitY: endGame(true); return
+- // monster moves after player
+- monsterMove()
+- // monster catches player?
+- if monsterX==playerX && monsterY==playerY: endGame(false); return
+- if timeLeft <= 0: endGame(false); return
+- render()
+
+// Monster movement (fixed logic)
+monsterMove():
+- if gameOver return
+- dx = playerX - monsterX; dy = playerY - monsterY
+- options = []
+- // prioritize reducing larger distance first (try horizontal then vertical or vice versa)
+- if Math.abs(dx) >= Math.abs(dy):
+    options.push([monsterX + Math.sign(dx), monsterY])   // try horizontal
+    options.push([monsterX, monsterY + Math.sign(dy)])   // then vertical
+  else:
+    options.push([monsterX, monsterY + Math.sign(dy)])   // try vertical
+    options.push([monsterX + Math.sign(dx), monsterY])   // then horizontal
+- // fallback neighbor moves (up,down,left,right)
+- options.push([monsterX+1,monsterY]); options.push([monsterX-1,monsterY])
+- options.push([monsterX,monsterY+1]); options.push([monsterX,monsterY-1])
+- // pick first valid option that is inside bounds and is a path (maze[oy][ox]==1)
+- for each (ox,oy) in options:
+    if ox >= 0 && oy >= 0 && ox < cols && oy < rows:
+      if maze[oy][ox] == 1:
+         monsterX = ox; monsterY = oy; break
+
+// End game
+endGame(win):
+- gameOver = true
+- message = win ? "üèÜ You escaped!" : "üíÄ The monster caught you!"
+- render()
+
+// Render: show large emoji grid (player & monster as emoji)
+render():
+- Build a multiline string (use a fixed-width block or preformatted text) where each cell is:
+    if x==playerX && y==playerY ‚Üí "üßç"
+    else if x==monsterX && y==monsterY ‚Üí "üëπ"
+    else if x==exitX && y==exitY ‚Üí "üüß"   // exit neon orange
+    else if maze[y][x] == 0 ‚Üí "üü•"         // wall neon red
+    else ‚Üí "üü¶"                             // path neon blue
+- Display the grid in a large font-size (set container style to large/xx-large or use <pre> with font-size:32px) so tiles are visually big and readable.
+- Always display: Title, message, grid, controls (Up/Down/Left/Right), and a visible Restart button that calls initGame().
+- DO NOT display any debug lines or coordinate text.
+
+UI Buttons:
+- Up ‚Üí move("Up")
+- Down ‚Üí move("Down")
+- Left ‚Üí move("Left")
+- Right ‚Üí move("Right")
+- Restart ‚Üí initGame()
+
+Important notes: 
+- exit must not be blocked by walls
+- player is never blocked at start.
+- monster is never blocked
+-  guarantees exit and monster spawn on reachable path tiles; therefore restarted mazes will always be solvable and monster will have space to move..
+- MonsterMove logic examines all neighbors and picks the neighbor that reduces distance; fallback neighbor scan prevents being stuck.
+- Keep maze cell check consistent: maze[y][x] == 1 means walkable. 
+- Use the exact maze cell checks (maze[y][x]==1 means walkable)

# 2025-12-03 09:57:10.867915
+Title: Monster Chase Maze ‚Äî Emoji Grid (Fixed)
+Description: 10√ó10 neon maze. Player üßç and Monster üëπ shown as emoji, exit üüß. Big visible grid, restart always works. Monster chase logic fixed.
+
+Category: Game
+Style: Text + emoji grid, DOM-friendly.
+
+Persistent State:
+- maze (2D array)          // 0 = wall, 1 = path
+- rows = 10
+- cols = 10
+- playerX, playerY
+- monsterX, monsterY
+- exitX, exitY
+- moves, timeLeft
+- message
+- gameOver
+
+On App Load:
+Call initGame() automatically.
+
+initGame():
+- rows = 10; cols = 10
+- // create full walls
+- maze = new 2D array rows√ócols with all cells = 0
+- // carve a guaranteed path from (0,0) to (cols-1,rows-1)
+- x = 0; y = 0; maze[y][x] = 1
+- while x < cols-1 or y < rows-1:
+    if Math.random() < 0.5 and x < cols-1:
+      x += 1
+    else if y < rows-1:
+      y += 1
+    maze[y][x] = 1
+- // open extra random path cells so maze is not a straight corridor
+- for i from 0 to 40:
+    rx = floor(Math.random()*cols); ry = floor(Math.random()*rows)
+    maze[ry][rx] = 1
+- // choose start / monster / exit on path cells
+- playerX = 0; playerY = 0; // ensure maze[0][0] == 1
+- // find monster start: search for a path cell near bottom-right
+- monsterX = cols-1; monsterY = rows-1
+- if maze[monsterY][monsterX] == 0:
+    // find nearest path cell to bottom-right
+    for yy from rows-1 downto 0:
+      for xx from cols-1 downto 0:
+        if maze[yy][xx] == 1:
+           monsterX = xx; monsterY = yy; break loops
+- // set exit to a random path cell not overlapping player/monster
+- do:
+    exitX = floor(Math.random()*cols); exitY = floor(Math.random()*rows)
+  while maze[exitY][exitX] != 1 || (exitX==playerX && exitY==playerY) || (exitX==monsterX && exitY==monsterY)
+- moves = 0; timeLeft = 30; gameOver = false
+- message = "Escape the maze! Use buttons. Restart always available."
+- render()
+
+// Movement input
+move(dir):
+- if gameOver return
+- nx = playerX; ny = playerY
+- if dir=="Up" then ny -= 1
+- if dir=="Down" then ny += 1
+- if dir=="Left" then nx -= 1
+- if dir=="Right" then nx += 1
+- if nx < 0 || ny < 0 || nx >= cols || ny >= rows then return
+- if maze[ny][nx] == 0 then return
+- // valid: move player
+- playerX = nx; playerY = ny; moves += 1; timeLeft -= 1
+- // win check
+- if playerX==exitX && playerY==exitY: endGame(true); return
+- // monster moves after player
+- monsterMove()
+- // monster catches player?
+- if monsterX==playerX && monsterY==playerY: endGame(false); return
+- if timeLeft <= 0: endGame(false); return
+- render()
+
+// Monster movement (fixed logic)
+monsterMove():
+- if gameOver return
+- dx = playerX - monsterX; dy = playerY - monsterY
+- options = []
+- // prioritize reducing larger distance first (try horizontal then vertical or vice versa)
+- if Math.abs(dx) >= Math.abs(dy):
+    options.push([monsterX + Math.sign(dx), monsterY])   // try horizontal
+    options.push([monsterX, monsterY + Math.sign(dy)])   // then vertical
+  else:
+    options.push([monsterX, monsterY + Math.sign(dy)])   // try vertical
+    options.push([monsterX + Math.sign(dx), monsterY])   // then horizontal
+- // fallback neighbor moves (up,down,left,right)
+- options.push([monsterX+1,monsterY]); options.push([monsterX-1,monsterY])
+- options.push([monsterX,monsterY+1]); options.push([monsterX,monsterY-1])
+- // pick first valid option that is inside bounds and is a path (maze[oy][ox]==1)
+- for each (ox,oy) in options:
+    if ox >= 0 && oy >= 0 && ox < cols && oy < rows:
+      if maze[oy][ox] == 1:
+         monsterX = ox; monsterY = oy; break
+
+// End game
+endGame(win):
+- gameOver = true
+- message = win ? "üèÜ You escaped!" : "üíÄ The monster caught you!"
+- render()
+
+// Render: show large emoji grid (player & monster as emoji)
+render():
+- Build a multiline string (use a fixed-width block or preformatted text) where each cell is:
+    if x==playerX && y==playerY ‚Üí "üßç"
+    else if x==monsterX && y==monsterY ‚Üí "üëπ"
+    else if x==exitX && y==exitY ‚Üí "üüß"   // exit neon orange
+    else if maze[y][x] == 0 ‚Üí "üü•"         // wall neon red
+    else ‚Üí "üü¶"                             // path neon blue
+- Display the grid in a large font-size (set container style to large/xx-large or use <pre> with font-size:32px) so tiles are visually big and readable.
+- Always display: Title, message, grid, controls (Up/Down/Left/Right), and a visible Restart button that calls initGame().
+- DO NOT display any debug lines or coordinate text.
+
+UI Buttons:
+- Up ‚Üí move("Up")
+- Down ‚Üí move("Down")
+- Left ‚Üí move("Left")
+- Right ‚Üí move("Right")
+- Restart ‚Üí initGame()
+
+Important notes: 
+- The exit must always be free and reachable. 
+- The exit must never be blocked by walls.
+- player is never blocked at start.
+- monster is never blocked
+-  guarantees exit and monster spawn on reachable path tiles; therefore restarted mazes will always be solvable and monster will have space to move..
+- MonsterMove logic examines all neighbors and picks the neighbor that reduces distance; fallback neighbor scan prevents being stuck.
+- Keep maze cell check consistent: maze[y][x] == 1 means walkable.
+- Use the exact maze cell checks (maze[y][x]==1 means walkable).

# 2025-12-03 09:57:10.868958
+Title: Monster Chase Maze ‚Äî Emoji Grid (Fixed)
+Description: 10√ó10 neon maze. Player üßç and Monster üëπ shown as emoji, exit üüß. Big visible grid, restart always works. Monster chase logic fixed.
+
+Category: Game
+Style: Text + emoji grid, DOM-friendly.
+
+Persistent State:
+- maze (2D array)          // 0 = wall, 1 = path
+- rows = 10
+- cols = 10
+- playerX, playerY
+- monsterX, monsterY
+- exitX, exitY
+- moves, timeLeft
+- message
+- gameOver
+
+On App Load:
+Call initGame() automatically.
+
+initGame():
+- rows = 10; cols = 10
+- // create full walls
+- maze = new 2D array rows√ócols with all cells = 0
+- // carve a guaranteed path from (0,0) to (cols-1,rows-1)
+- x = 0; y = 0; maze[y][x] = 1
+- while x < cols-1 or y < rows-1:
+    if Math.random() < 0.5 and x < cols-1:
+      x += 1
+    else if y < rows-1:
+      y += 1
+    maze[y][x] = 1
+- // open extra random path cells so maze is not a straight corridor
+- for i from 0 to 40:
+    rx = floor(Math.random()*cols); ry = floor(Math.random()*rows)
+    maze[ry][rx] = 1
+- // choose start / monster / exit on path cells
+- playerX = 0; playerY = 0; // ensure maze[0][0] == 1
+- // find monster start: search for a path cell near bottom-right
+- monsterX = cols-1; monsterY = rows-1
+- if maze[monsterY][monsterX] == 0:
+    // find nearest path cell to bottom-right
+    for yy from rows-1 downto 0:
+      for xx from cols-1 downto 0:
+        if maze[yy][xx] == 1:
+           monsterX = xx; monsterY = yy; break loops
+- // set exit to a random path cell not overlapping player/monster
+- do:
+    exitX = floor(Math.random()*cols); exitY = floor(Math.random()*rows)
+  while maze[exitY][exitX] != 1 || (exitX==playerX && exitY==playerY) || (exitX==monsterX && exitY==monsterY)
+- moves = 0; timeLeft = 30; gameOver = false
+- message = "Escape the maze! Use buttons. Restart always available."
+- render()
+
+// Movement input
+move(dir):
+- if gameOver return
+- nx = playerX; ny = playerY
+- if dir=="Up" then ny -= 1
+- if dir=="Down" then ny += 1
+- if dir=="Left" then nx -= 1
+- if dir=="Right" then nx += 1
+- if nx < 0 || ny < 0 || nx >= cols || ny >= rows then return
+- if maze[ny][nx] == 0 then return
+- // valid: move player
+- playerX = nx; playerY = ny; moves += 1; timeLeft -= 1
+- // win check
+- if playerX==exitX && playerY==exitY: endGame(true); return
+- // monster moves after player
+- monsterMove()
+- // monster catches player?
+- if monsterX==playerX && monsterY==playerY: endGame(false); return
+- if timeLeft <= 0: endGame(false); return
+- render()
+
+// Monster movement (fixed logic)
+monsterMove():
+- if gameOver return
+- dx = playerX - monsterX; dy = playerY - monsterY
+- options = []
+- // prioritize reducing larger distance first (try horizontal then vertical or vice versa)
+- if Math.abs(dx) >= Math.abs(dy):
+    options.push([monsterX + Math.sign(dx), monsterY])   // try horizontal
+    options.push([monsterX, monsterY + Math.sign(dy)])   // then vertical
+  else:
+    options.push([monsterX, monsterY + Math.sign(dy)])   // try vertical
+    options.push([monsterX + Math.sign(dx), monsterY])   // then horizontal
+- // fallback neighbor moves (up,down,left,right)
+- options.push([monsterX+1,monsterY]); options.push([monsterX-1,monsterY])
+- options.push([monsterX,monsterY+1]); options.push([monsterX,monsterY-1])
+- // pick first valid option that is inside bounds and is a path (maze[oy][ox]==1)
+- for each (ox,oy) in options:
+    if ox >= 0 && oy >= 0 && ox < cols && oy < rows:
+      if maze[oy][ox] == 1:
+         monsterX = ox; monsterY = oy; break
+
+// End game
+endGame(win):
+- gameOver = true
+- message = win ? "üèÜ You escaped!" : "üíÄ The monster caught you!"
+- render()
+
+// Render: show large emoji grid (player & monster as emoji)
+render():
+- Build a multiline string (use a fixed-width block or preformatted text) where each cell is:
+    if x==playerX && y==playerY ‚Üí "üßç"
+    else if x==monsterX && y==monsterY ‚Üí "üëπ"
+    else if x==exitX && y==exitY ‚Üí "üüß"   // exit neon orange
+    else if maze[y][x] == 0 ‚Üí "üü•"         // wall neon red
+    else ‚Üí "üü¶"                             // path neon blue
+- Display the grid in a large font-size (set container style to large/xx-large or use <pre> with font-size:32px) so tiles are visually big and readable.
+- Always display: Title, message, grid, controls (Up/Down/Left/Right), and a visible Restart button that calls initGame().
+- DO NOT display any debug lines or coordinate text.
+
+UI Buttons:
+- Up ‚Üí move("Up")
+- Down ‚Üí move("Down")
+- Left ‚Üí move("Left")
+- Right ‚Üí move("Right")
+- Restart ‚Üí initGame()
+
+Important notes: 
+- The exit must always be free and reachable. 
+- The exit must never be blocked by walls.
+- player is never blocked at start.
+- monster is never blocked
+-  guarantees exit and monster spawn on reachable path tiles; therefore restarted mazes will always be solvable and monster will have space to move..
+- MonsterMove logic examines all neighbors and picks the neighbor that reduces distance; fallback neighbor scan prevents being stuck.
+- Keep maze cell check consistent: maze[y][x] == 1 means walkable.
+- Use the exact maze cell checks (maze[y][x]==1 means walkable).
